<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="SSR,">










<meta name="description" content="本章通过动手搭建一个基于 Vue.js 的 SSR 项目，深入学习 SSR 的实现，项目使用 webpack 4.x 打包项目和 Vuex 管理数据。  Vue SSR 介绍什么是服务器端渲染 (SSR)Vue SSR（Vue.js Server-Side Rendering）是 Vue.js 官方提供的一个服务端渲染（同构应用）解决方案，使用它可以构建同构应用，而Vue SSR依旧基于原有的">
<meta name="keywords" content="SSR">
<meta property="og:type" content="article">
<meta property="og:title" content="【服务器端渲染】-- Vue-SSR">
<meta property="og:url" content="http://yoursite.com/2021/03/26/【服务器端渲染】-- Vue-SSR/index.html">
<meta property="og:site_name" content="Eline blog">
<meta property="og:description" content="本章通过动手搭建一个基于 Vue.js 的 SSR 项目，深入学习 SSR 的实现，项目使用 webpack 4.x 打包项目和 Vuex 管理数据。  Vue SSR 介绍什么是服务器端渲染 (SSR)Vue SSR（Vue.js Server-Side Rendering）是 Vue.js 官方提供的一个服务端渲染（同构应用）解决方案，使用它可以构建同构应用，而Vue SSR依旧基于原有的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr1.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr2.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr3.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr4.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr5.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr6.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr7.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr8.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr9.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr10.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr11.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr12.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr13.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr14.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr15.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr16.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr18.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr19.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr17.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr20.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr21.png">
<meta property="og:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr22.png">
<meta property="og:updated_time" content="2021-04-01T09:16:04.444Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【服务器端渲染】-- Vue-SSR">
<meta name="twitter:description" content="本章通过动手搭建一个基于 Vue.js 的 SSR 项目，深入学习 SSR 的实现，项目使用 webpack 4.x 打包项目和 Vuex 管理数据。  Vue SSR 介绍什么是服务器端渲染 (SSR)Vue SSR（Vue.js Server-Side Rendering）是 Vue.js 官方提供的一个服务端渲染（同构应用）解决方案，使用它可以构建同构应用，而Vue SSR依旧基于原有的">
<meta name="twitter:image" content="http://yoursite.com/2021/03/26/【服务器端渲染】--%20Vue-SSR/ssr1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/26/【服务器端渲染】-- Vue-SSR/">





  <title>【服务器端渲染】-- Vue-SSR | Eline blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eline blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/【服务器端渲染】-- Vue-SSR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eline">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eline blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【服务器端渲染】-- Vue-SSR</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-26T15:18:35+08:00">
                2021-03-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-04-01T17:16:04+08:00">
                2021-04-01
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vueJS/" itemprop="url" rel="index">
                    <span itemprop="name">vueJS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本章通过动手搭建一个基于 Vue.js 的 SSR 项目，深入学习 SSR 的实现，项目使用 webpack 4.x 打包项目和 Vuex 管理数据。</p>
</blockquote>
<h2 id="Vue-SSR-介绍"><a href="#Vue-SSR-介绍" class="headerlink" title="Vue SSR 介绍"></a>Vue SSR 介绍</h2><h3 id="什么是服务器端渲染-SSR"><a href="#什么是服务器端渲染-SSR" class="headerlink" title="什么是服务器端渲染 (SSR)"></a>什么是服务器端渲染 (SSR)</h3><p><a href="https://ssr.vuejs.org/" target="_blank" rel="noopener">Vue SSR</a>（Vue.js Server-Side Rendering）是 Vue.js 官方提供的一个服务端渲染（同构应用）解决方案，使用它可以构建同构应用，而Vue SSR依旧基于原有的 Vue.js 技术栈。</p>
<blockquote>
<p>官方文档的解释：Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><strong>技术层面：</strong></p>
<ul>
<li>更快的首屏渲染速度</li>
<li>更好的 SEO</li>
</ul>
<p><strong>业务层面：</strong></p>
<ul>
<li>不适合管理系统</li>
<li>适合门户资讯类网站，例如企业官网、知乎、简书等</li>
<li>适合移动网站</li>
</ul>
<h3 id="如何实现-Vue-SSR"><a href="#如何实现-Vue-SSR" class="headerlink" title="如何实现 Vue SSR"></a>如何实现 Vue SSR</h3><ol>
<li>基于 Vue SSR 官方文档提供的解决方案</li>
</ol>
<p>官方方案具有更直接的控制应用程序的结构，更深入底层，更加灵活，同时在使用官方方案的过程中，也会对Vue SSR有更加深入的了解。</p>
<p>该方式需要熟悉 Vue.js 本身，并且具有 Node.js 和 webpack 的相当不错的应用经验。</p>
<ol start="2">
<li>Nuxt.js 开发框架</li>
</ol>
<p>Nuxt 提供了平滑的开箱即用的体验，它建立在同等的 Vue 技术栈之上，但抽象出很多模板，并提供了一些额外的功能，例如静态站点生成。通过 Nuxt.js 可以快速的使用 Vue SSR 构建同构应用。</p>
<h2 id="Vue-SSR-基本使用"><a href="#Vue-SSR-基本使用" class="headerlink" title="Vue SSR 基本使用"></a>Vue SSR 基本使用</h2><p>接下来以 Vue SSR 的官方文档为参考，来学习一下它的基本用法。</p>
<h3 id="渲染一个-Vue-实例"><a href="#渲染一个-Vue-实例" class="headerlink" title="渲染一个 Vue 实例"></a>渲染一个 Vue 实例</h3><blockquote>
<p>目的：了解下如何使用 Vue SSR 将一个 Vue 实例渲染为 HTML 字符串</p>
</blockquote>
<p>首先，我们来学习一下服务端渲染中最基础的工作：<strong>模板渲染</strong>。 简单来说就是如何在服务端使用 Vue 的方式解析替换字符串。</p>
<p>在它的官方文档中其实已经给出了示例代码，下面我们来把这个案例的实现过程以及其中含义演示一下。</p>
<ul>
<li>准备工作</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建文件夹</span><br><span class="line">$ mkdir vue-ssr</span><br><span class="line"># 进入创建的文件夹内</span><br><span class="line">$ cd vue-ssr</span><br><span class="line"># 初始化包管理文件 package.json</span><br><span class="line">$ npm init -y # -y 表示快速初始，不经过一些问题的回答，直接走默认回答</span><br><span class="line"># 安装 vue 及 vue-server-renderer 依赖包</span><br><span class="line">$ npm install vue vue-server-renderer --save</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 <code>server.js</code> 文件，将 Vue 实例渲染成 HTML 字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 步：创建一个 Vue 实例</span></span><br><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div id="app"&gt;</span></span><br><span class="line"><span class="string">            &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;`</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:<span class="string">'vue实例'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 步：创建一个 renderer 渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>).createRenderer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 步：将 Vue 实例渲染为 HTML</span></span><br><span class="line">renderer.renderToString(app, (err, html) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="comment">// html 就是渲染出来的结果字符串</span></span><br><span class="line">    <span class="built_in">console</span>.log(html); <span class="comment">// &lt;div id="app" data-server-rendered="true"&gt;&lt;h1&gt;拉勾教育&lt;/h1&gt;&lt;/div&gt;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 2.5.0+，如果没有传入回调函数，则会返回 Promise：</span></span><br><span class="line"><span class="comment">renderer.renderToString(app)</span></span><br><span class="line"><span class="comment">    .then((html) =&gt; &#123;</span></span><br><span class="line"><span class="comment">        console.log(html);</span></span><br><span class="line"><span class="comment">        &#125;)</span></span><br><span class="line"><span class="comment">    .catch((err) =&gt; &#123;</span></span><br><span class="line"><span class="comment">        console.error(err);</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 node 运行 <code>server.js</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr1.png" alt="vue ssr"></p>
<p> 通过渲染结果可以看到模板根节点中添加了<code>data-server-rendered=&quot;true&quot;</code>字段，主要用于将来客户端渲染激活接管的一个入口</p>
<h3 id="与服务器集成"><a href="#与服务器集成" class="headerlink" title="与服务器集成"></a>与服务器集成</h3><p>在 Node.js 服务器中使用时相当简单直接，例如 <a href="https://expressjs.com/zh-cn/" target="_blank" rel="noopener">Express</a>,具体使用如下：</p>
<ul>
<li>首先，安装 Express 到项目中</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express --save</span><br></pre></td></tr></table></figure>
<ul>
<li>然后，使用 Express 创建一个基本的 Web 服务,在 Web 服务中渲染 Vue 实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> server = express()</span><br><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>).createRenderer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由</span></span><br><span class="line">server.get(<span class="string">'/'</span>,(req, res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        template:<span class="string">`</span></span><br><span class="line"><span class="string">            &lt;div id="app"&gt;</span></span><br><span class="line"><span class="string">                &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message:<span class="string">'vue实例'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    renderer.renderToString( app, (err,html) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.status(<span class="number">500</span>).end(<span class="string">'Internal Server Error'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// res.end(html)</span></span><br><span class="line">        <span class="comment">// 解决乱码:添加 html响应头或使用 meta 设置编码格式</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html; charset=utf-8'</span>)</span><br><span class="line">        res.end(<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">            &lt;html&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;</span></span><br><span class="line"><span class="string">                &lt;meta charset="utf-8"&gt;</span></span><br><span class="line"><span class="string">                &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">                &lt;meta name="renderer" content="webkit" /&gt;</span></span><br><span class="line"><span class="string">                &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;</span></span><br><span class="line"><span class="string">            &lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;</span></span><br><span class="line"><span class="string">             <span class="subst">$&#123;html&#125;</span></span></span><br><span class="line"><span class="string">            &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server runing at port 3000'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>启动 Web 服务，nodemon 启动服务，可以实时监听，热更新：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nodemon server.js</span><br></pre></td></tr></table></figure>
<p>运行结果如下所示：<br> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr2.png" alt="vue ssr"></p>
<h3 id="使用一个页面模板"><a href="#使用一个页面模板" class="headerlink" title="使用一个页面模板"></a>使用一个页面模板</h3><p>将上面进一步优化，将模板提取为一个单独的页面</p>
<ul>
<li>创建一个页面模板 index.html</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 使用三花括号(triple-mustache)进行 HTML 不转义插值(non-HTML-escaped interpolation) --&gt;</span></span><br><span class="line">    &#123;&#123;&#123; meta &#125;&#125;&#125;</span><br><span class="line">     <span class="comment">&lt;!-- 使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--vue-ssr-outlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：上面的 <!--vue-ssr-outlet--> 注释语句，是固定语法。会作为 Vue 实例 转换的 html 字符串存放的位置，类似于占位。vue-ssr-outlet 前后不可以有空格。</p>
<ul>
<li>在 <code>server.js</code> 中，创建 renderer 渲染器时，添加一个 template 参数，指定模板</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>).createRenderer(&#123;</span><br><span class="line">    <span class="comment">// 添加模板，读取文件是二进制形式，需要转码</span></span><br><span class="line">    template: fs.readFileSync(<span class="string">'./index.html'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 添加路由</span></span><br><span class="line">server.get(<span class="string">'/'</span>,(req, res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        template:<span class="string">`</span></span><br><span class="line"><span class="string">            &lt;div id="app"&gt;</span></span><br><span class="line"><span class="string">                &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                &lt;h2&gt;客户端动态交互&lt;/h2&gt;</span></span><br><span class="line"><span class="string">                &lt;div&gt;</span></span><br><span class="line"><span class="string">                    &lt;input v-model = "message"&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">                &lt;div&gt;</span></span><br><span class="line"><span class="string">                    &lt;button @click="onClick"&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;`</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message:<span class="string">'vue ssr'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            onClick()&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    renderer.renderToString( app, &#123;</span><br><span class="line">        <span class="comment">// 在模板中使用外部数据(renderToString第二个参数为可选)</span></span><br><span class="line">        <span class="comment">// 页面 title 将会是 "Hello"</span></span><br><span class="line">        title:<span class="string">'Hello'</span>,</span><br><span class="line">        <span class="comment">// meta 标签也会注入</span></span><br><span class="line">        meta: <span class="string">`&lt;meta name="description" content="vue实例"&gt;`</span></span><br><span class="line">    &#125;, (err,html) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.status(<span class="number">500</span>).end(<span class="string">'Internal Server Error'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解决乱码:添加 html响应头或使用 meta 设置编码格式</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html; charset=utf-8'</span>)</span><br><span class="line">        <span class="comment">// html 将是注入应用程序内容的完整页面</span></span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr3.png" alt="vue ssr"></p>
<p> 通过运行结果可以看到，可以通过传入一个”渲染上下文对象”，作为 renderToString 函数的第二个参数，来提供插值数据，插入到模板中，但是服务端渲染只是把 vue 实例处理成纯静态的HTML字符串发送给客户端，在 vue 实例中，需要客户端动态交互的功能，本身并没有提供，例如<code>&lt;input v-model = &quot;message&quot;&gt;</code> input 标签通过 v-model 绑定数据 message，当input 发生改变的时候，message 也会改变，所有绑定message的位置也随之变化，通过测试发现改变 input 内容改变后 message 值并未发生变化。</p>
<p> 原因：服务端渲染出来的文件并没有客户端 js 相关内容，所以目前没有客户端交互的能力，如何实现呢？下面将详细介绍</p>
<h2 id="构建同构渲染-构建流程"><a href="#构建同构渲染-构建流程" class="headerlink" title="构建同构渲染 - 构建流程"></a>构建同构渲染 - <a href="https://ssr.vuejs.org/zh/guide/structure.html#%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E5%8D%95%E4%BE%8B" target="_blank" rel="noopener">构建流程</a></h2><p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr4.png" alt="vue ssr"></p>
<p>如上图：左边为应用的源代码 Source ，中间为 Webpack ，右边为 NodeServer 服务端。</p>
<p>在我们的应用当中，目前只有 Server entry 服务端入口来处理服务端渲染，如果我们希望服务端渲染的内容拥有客户端动态交互的能力的话，还需要有一个客户端脚本的入口 Client entry，它专门来处理客户端渲染，也就是去接管服务端渲染的内容把它激活为一个动态页面。</p>
<p>有了这两个入口之后需要 Webpack 对它们进行打包编译构建：对于 Server entry 最终要打包为一个 ServerBundle 来做服务端渲染，同样的对于客户端入口 Client entry 来说最终要打包为一个ClientBundle来接管服务端渲染好的静态页面对它进行激活。</p>
<p>这就是同构应用实现的一个基本流程。</p>
<h2 id="构建同构渲染-源码结构"><a href="#构建同构渲染-源码结构" class="headerlink" title="构建同构渲染 - 源码结构"></a>构建同构渲染 - 源码结构</h2><p>我们需要使用 webpack 来打包我们的 Vue 应用程序。事实上，我们可能需要在服务器上使用 webpack 打包 Vue 应用程序，因为：</p>
<ul>
<li>通常 Vue 应用程序是由 webpack 和 vue-loader 构建，并且许多 webpack 特定功能不能直接在 Node.js 中运行（例如通过 file-loader 导入文件，通过 css-loader 导入 CSS）。</li>
<li>尽管 Node.js 最新版本能够完全支持 ES2015 特性，我们还是需要转译客户端代码以适应老版浏览器。这也会涉及到构建步骤。</li>
</ul>
<p>所以基本看法是，对于客户端应用程序和服务器应用程序，我们都要使用 webpack 打包-服务器需要「服务器 bundle」然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记。</p>
<p>现在我们正在使用 webpack 来处理服务器和客户端的应用程序，大部分源码可以使用通用方式编写，可以使用 webpack 支持的所有功能。同时，在编写通用代码时，有一些<a href="https://ssr.vuejs.org/zh/guide/universal.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94" target="_blank" rel="noopener">事项</a>要牢记在心。</p>
<p>项目中src目录的基本结构<br>    src<br>    ├── pages<br>    │   ├── Home.vue<br>    │   ├── About.vue<br>    │   └── Post.vue<br>    ├── App.vue         # 根组件<br>    ├── app.js          # 通用 entry(universal entry)<br>    ├── entry-client.js # 仅运行于浏览器<br>    └── entry-server.js # 仅运行于服务器</p>
<h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;客户端动态交互&lt;/h2&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input v-model=&quot;message&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button @click=&quot;onClick&quot;&gt;点击测试&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &apos;vue ssr&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onClick () &#123;</span><br><span class="line">      console.log(&apos;Hello World!&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><p><code>app.js</code> 是我们应用程序的「通用 entry」。在纯客户端应用程序中，我们将在此文件中创建根 Vue 实例，并直接挂载到 DOM。但是，对于服务器端渲染(SSR)，责任就会转移到纯客户端 entry 文件。app.js 简单地使用 export 导出一个 createApp 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个工厂函数，用于创建新的</span></span><br><span class="line"><span class="comment">// 应用程序、router 和 store 实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        <span class="comment">// 根实例简单的渲染应用程序组件。</span></span><br><span class="line">        render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 后期还有导出 router 、store实例</span></span><br><span class="line">    <span class="keyword">return</span> &#123; app &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：<strong>避免状态单例</strong></p>
<p>当编写纯客户端 (client-only) 代码时，我们习惯于每次在新的上下文中对代码进行取值。但是 Node.js 服务器是一个长期运行的进程。当我们的代码进入该进程时，它将进行一次取值并留存在内存中。这意味着如果创建一个单例对象，它将在每个传入的请求之间共享。</p>
<p>如基本示例所示，我们为每个请求创建一个新的根 Vue 实例。这与每个用户在自己的浏览器中使用新应用程序的实例类似。如果我们在多个请求之间使用一个共享的实例，很容易导致交叉请求状态污染 (cross-request state pollution)。</p>
<p>因此，我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序、router 和 store 实例。</p>
<h3 id="entry-client-js"><a href="#entry-client-js" class="headerlink" title="entry-client.js"></a>entry-client.js</h3><p>客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端入口</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端特定引导逻辑……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里假定 App.vue 模板中根元素具有 `id="app"`</span></span><br><span class="line">app.$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="entry-server-js"><a href="#entry-server-js" class="headerlink" title="entry-server.js"></a>entry-server.js</h3><p>服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情， 但是稍后我们将在此执行服务器端路由匹配 (server-side route matching) 和数据预取逻辑 (data pre-fetching logic)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端入口</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构建同构渲染-构建配置"><a href="#构建同构渲染-构建配置" class="headerlink" title="构建同构渲染 - 构建配置"></a>构建同构渲染 - 构建配置</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol>
<li>安装生产依赖</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i vue vue-server-renderer express cross-env</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>包</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>vue</td>
<td>Vue.js 核心库</td>
</tr>
<tr>
<td>vue-server-renderer</td>
<td>Vue 服务端渲染工具</td>
</tr>
<tr>
<td>express</td>
<td>基于 Node 的 Web 服务框架</td>
</tr>
<tr>
<td>cross-env</td>
<td>通过 npm scripts 设置跨平台环境变量,区分不同的打包环境，使用process.env.NODE_ENV获取当前的环境</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>安装开发依赖</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -D webpack webpack-cli webpack-merge webpack-node-externals @babel/core @babel/plugin-transform-runtime @babel/preset-env babel-loader css-loader url-loader file-loader rimraf vue-loader vue-template-compiler friendly-errors-webpack-plugin</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>包</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>webpack</td>
<td>webpack 核心包</td>
</tr>
<tr>
<td>webpack-cli</td>
<td>ebpack 的命令行工具</td>
</tr>
<tr>
<td>webpack-merge</td>
<td>webpack 配置信息合并工具</td>
</tr>
<tr>
<td>webpack-node-externals</td>
<td>排除 webpack 中的 Node 模块</td>
</tr>
<tr>
<td>rimraf</td>
<td>基于 Node 封装的一个跨平台 rm -rf 工具</td>
</tr>
<tr>
<td>friendly-errors-webpack-plugin</td>
<td>友好的 webpack 错误提示</td>
</tr>
<tr>
<td>@babel/core、@babel/plugin-transform-runtime、 @babel/preset-env、 babel-loader</td>
<td>Babel 相关工具（ES6转ES5）</td>
</tr>
<tr>
<td>vue-loader、 vue-template-compiler</td>
<td>处理 .vue 资源</td>
</tr>
<tr>
<td>file-loader</td>
<td>处理字体资源</td>
</tr>
<tr>
<td>css-loader</td>
<td>处理 CSS 资源</td>
</tr>
<tr>
<td>url-loader</td>
<td>处理图片资源</td>
</tr>
</tbody>
</table>
<h3 id="配置文件及打包命令"><a href="#配置文件及打包命令" class="headerlink" title="配置文件及打包命令"></a>配置文件及打包命令</h3><ul>
<li><p>初始化 webpack 打包配置文件</p>
<pre><code>build
├── webpack.base.config.js   # 公共配置
├── webpack.client.config.js # 客户端打包配置文件
└── webpack.server.config.js # 服务端打包配置文件
</code></pre></li>
</ul>
<p>webpack打包配置文件的代码详见 <a href="https://github.com/Eline302/my-vueSSR/blob/main/build/webpack.base.config.js" target="_blank" rel="noopener">build</a></p>
<ul>
<li>在 package.json 的 scripts 中配置打包命令</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"build:client": "cross-env NODE_ENV=production webpack --config build/webpack.client.config.js", </span><br><span class="line">"build:server": "cross-env NODE_ENV=production webpack --config build/webpack.server.config.js",</span><br><span class="line">"build": "rimraf dist &amp;&amp; npm run build:client &amp;&amp; npm run build:server",</span><br></pre></td></tr></table></figure>
<ul>
<li>运行测试</li>
</ul>
<p>客户端打包，命令执行及输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build:client</span><br></pre></td></tr></table></figure>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr5.png" alt="vue ssr"></p>
<p>服务端打包，命令执行及输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build:server</span><br></pre></td></tr></table></figure>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr6.png" alt="vue ssr"></p>
<p>同时打包客户端和服务端，命令执行及输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr7.png" alt="vue ssr"></p>
<h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><ul>
<li>参考网址：<a href="https://ssr.vuejs.org/zh/guide/bundle-renderer.html" target="_blank" rel="noopener">https://ssr.vuejs.org/zh/guide/bundle-renderer.html</a></li>
<li><code>server.js</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Vue = <span class="built_in">require</span>(<span class="string">'vue'</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-server-bundle.json'</span>)</span><br><span class="line"><span class="keyword">const</span> template = fs.readFileSync(<span class="string">'./index.html'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment">// 生成的客户端清单 (client manifest) </span></span><br><span class="line"><span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-client-manifest.json'</span>)</span><br><span class="line"><span class="comment">// 创建一个渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>).createBundleRenderer(serverBundle, &#123;</span><br><span class="line">    <span class="comment">// 设置模板</span></span><br><span class="line">    template,</span><br><span class="line">    clientManifest</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 experss 的 server 实例</span></span><br><span class="line"><span class="keyword">const</span> server = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开头的路径，需要与 output 中设置的 publicPath 保持一致</span></span><br><span class="line">server.use(<span class="string">'/dist'</span>, express.static(<span class="string">'./dist'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由</span></span><br><span class="line">server.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param &#123;Vue&#125; </span></span><br><span class="line"><span class="comment">     * @param &#123;Object&#125; </span></span><br><span class="line"><span class="comment">     * @param &#123;Function&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    renderer.renderToString(&#123;</span><br><span class="line">        <span class="comment">// 配置传到模板中的数据</span></span><br><span class="line">        title: <span class="string">'vue ssr'</span>,</span><br><span class="line">        meta: <span class="string">`&lt;meta name="description" content="vue-SSR"&gt;`</span></span><br><span class="line">    &#125;, (err, html) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.status(<span class="number">500</span>).end(<span class="string">'Internal Server Error'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// html 就是渲染出来的结果字符串</span></span><br><span class="line">        <span class="comment">// 添加响应头，解决编码问题</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf8'</span>)</span><br><span class="line">        <span class="comment">// 结合了模板的完整内容</span></span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server running at port 3000'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="解析渲染流程"><a href="#解析渲染流程" class="headerlink" title="解析渲染流程"></a>解析渲染流程</h3><h4 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h4><p>服务端是如何渲染并输出 html 文件？服务端渲染主要结合 serverBundl e文件，具体的流程如下：</p>
<p>从路由(server.js)这里着手，当客户端请求进来时候会被服务端路由匹配到，并调用 <code>renderer</code> 渲染器的 renderToString 方法进行渲染，把一个 vue 实例渲染成 html 字符串发送给客户端，但是在 <code>renderer.renderToString</code> 方法中并没有看到 vue 实例，那么这里的 vue 实例是怎么获取到的？<br>通过代码可以看到 <code>renderer</code> 渲染器是通过 <code>createBundleRenderer</code> 方法创建出来，方法的第一个参数是 serverBundle 即打包生成的 <code>vue-ssr-server-bundle.json</code> 文件，文件的具体内容如下：</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr8.png" alt="vue ssr"></p>
<p><code>server Bundle</code> 是 <code>Vue SSR</code> 构建的一个特殊的 JSON 文件,主要描述服务端打包的信息，包括如下内容：</p>
<ul>
<li>entry：服务端打包的入口（<code>server-bundle.js</code> 在打包时候配置的文件名）</li>
<li>files：所有构建结果资源列表 （<code>server-bundle.js</code>: 即 <code>entry-server.js</code> 构建出来的结果文件）</li>
<li>maps：源代码 source map 信息，主要在开发调试中使用</li>
</ul>
<p>那么 serverBundle 是如何被使用的？<br>render 在渲染的时候，会来加载 serverbundle 中的入口 entry，加载里面的代码并执行，就可以得到 entry-server.js 中创建的vue实例，把 vue 实例进行渲染，把渲染结果注入到 template 模板中（render的第二个参数），最后把数据发送到了客户端。</p>
<h4 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h4><p><strong>客户端如何接管激活服务端渲染后的内容？</strong><br>通过客户端构建打包出来的js脚本文件注入到页面（index.html）中，加载客户端脚本，但是我们在模板文件中并没有写这些代码，而是在构建结果输出到客户端页面中自动包含了这些脚本</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr9.png" alt="vue ssr"></p>
<p><strong>那么服务端是如何知道模板中需要引用加载客户端构建出来的结果呢？</strong><br>通过代码可以看到，<code>createBundleRenderer</code> 中配置了参数 <code>clientManifest</code> 即 <code>vue-ssr-client-manifest.json</code> ，它是客户端打包资源的一个构建清单，清单中描述了客户端构建资源的相关信息，具体内容如下：</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr10.png" alt="vue ssr"></p>
<ul>
<li>publicPath：访问静态资源的根相对路径，与 webpack 配置中的 publicPath 一致</li>
<li>all：客户端打包所有构建出来的静态资源名称</li>
<li>initial：页面初始化时需要加载的文件，会在页面加载时配置到 preload(提前加载) 中（在渲染的时候，会把 initial 中的资源通过 script 方式自动的注入到模板页面的<code>&lt;!--vue-ssr-outlet--&gt;</code>之后）</li>
<li>async：页面跳转时需要加载的异步资源文件，会在页面加载时配置到 prefetch(预判加载) 中</li>
<li>modules：项目的各个模块包含的文件的序号，对应 all 中文件的顺序，moduleIdentifier 和 all 数组中文件的映射关系（modules对象是我们查找文件引用的重要数据）<br>modules作用：当客户端在运行的时候，假如加载了一个模块，这个模块他用到那些资源，vue就会根据信息去加载这些资源</li>
</ul>
<p>通过 script 方式引入到模板中的客户端打包的 app.js 文件是如何工作的？</p>
<p>参考官方文档：<a href="https://ssr.vuejs.org/zh/guide/hydration.html" target="_blank" rel="noopener">客户端激活 (client-side hydration)</a></p>
<p>服务端渲染好内容想要拥有动态交互能力，需要客户端激活，接管服务端渲染好的内容，使其变为由 Vue 管理的动态 DOM 的过程。</p>
<p>在 entry-client.js 中，我们用下面这行挂载(mount)应用程序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里假定 App.vue template 根元素的 `id="app"`</span></span><br><span class="line">app.$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<p>由于服务器已经渲染好了 HTML，客户端不会在进行重新渲染。而是需要”激活”这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化），这个过程也称为“注水”</p>
<p>在浏览器中查看服务器渲染的输出结果，应用程序的根元素上添加了一个特殊的属性：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">data-server-rendered</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>data-server-rendered 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载,而不是通过完整的渲染模式，需要注意在根组件的根元素中需要添加 <code>id=&quot;app&quot;</code>，否则应用程序将无法正常激活。</p>
<p>在没有 data-server-rendered 属性的元素上，还可以向 $mount 函数的 hydrating 参数位置传入 true，来强制使用激活模式(hydration)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制使用应用程序的激活模式</span></span><br><span class="line">app.$mount(<span class="string">'#app'</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树 (virtual DOM tree)，是否与从服务器渲染的 DOM 结构 (DOM structure) 匹配。如果匹配，就直接激活，无需重新渲染，如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。<strong>在生产模式下，此检测会被跳过，以避免性能损耗</strong>。</p>
<h2 id="构建同构渲染-构建配置开发模式"><a href="#构建同构渲染-构建配置开发模式" class="headerlink" title="构建同构渲染 - 构建配置开发模式"></a>构建同构渲染 - 构建配置开发模式</h2><p>我们现在已经实现同构应用的基本功能了，但是这对于一个完整的应用来说还远远不够，例如如何处理同构应用中的路由、如何在服务端渲染中进行数据预取等功能。这些功能我们都会去对它进行实现，但是在实现它们之前我们先优化之前的代码，解决每次写完代码，都要重新打包构建，重新启动 Web 服务，让其变成一个编写完代码后自动构建并重启web服务器，自动刷新页面，下面我们来修改下：</p>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li><p>生产模式</p>
<ul>
<li>npm run build构建</li>
<li>node server 启动应用</li>
</ul>
</li>
<li><p>开发模式</p>
<ul>
<li>监视代码变动自动构建，热更新等功能</li>
<li>node server 启动应用</li>
</ul>
</li>
</ul>
<h4 id="配置启动脚本package-json"><a href="#配置启动脚本package-json" class="headerlink" title="配置启动脚本package.json"></a>配置启动脚本<code>package.json</code></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"start": "cross-env NODE_ENV=production node server.js",</span><br><span class="line">"dev": "node server.js"</span><br></pre></td></tr></table></figure>
<h4 id="服务端配置-server-js"><a href="#服务端配置-server-js" class="headerlink" title="服务端配置 server.js"></a>服务端配置 <code>server.js</code></h4><p>renderer 是通过打包的结果调用 createBundleRenderer 创建出来的。在生产模式下它是直接基于打包的结果创建的，但是在开发模式下 renderer 需要不断更新渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 服务端入口，仅运行于服务端 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建一个 experss 的 server 实例</span></span><br><span class="line"><span class="keyword">const</span> server = express()</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; createBundleRenderer &#125; = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>)</span><br><span class="line"><span class="keyword">const</span> setupDevServer = <span class="built_in">require</span>(<span class="string">'./build/setup-dev-server'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isPro = process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line"><span class="keyword">let</span> renderer</span><br><span class="line"><span class="keyword">let</span> onReady</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isPro) &#123;</span><br><span class="line">    <span class="keyword">const</span> template = fs.readFileSync(<span class="string">'./index.html'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">// 生产模式，直接基于已构建好的包创建渲染器</span></span><br><span class="line">    <span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-server-bundle.json'</span>)</span><br><span class="line">    <span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-client-manifest.json'</span>)</span><br><span class="line">    <span class="comment">// 创建一个渲染器</span></span><br><span class="line">    renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">        template, <span class="comment">// (可选) 设置页面模板</span></span><br><span class="line">        clientManifest <span class="comment">// (可选) 客户端构建</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 开发模式 --&gt; 监视打包构建（客户端 + 服务端） --&gt; 重新生成 Renderer 渲染器</span></span><br><span class="line">    onReady = setupDevServer(server, (serverBundle, template, clientManifest) =&gt; &#123;</span><br><span class="line">        renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">            template, <span class="comment">// (可选) 设置页面模板</span></span><br><span class="line">            clientManifest <span class="comment">// (可选) 客户端构建</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开头的路径，需要与 output 中设置的 publicPath 保持一致</span></span><br><span class="line">server.use(<span class="string">'/dist'</span>, express.static(<span class="string">'./dist'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="keyword">async</span> (req, res) =&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// renderToString支持promise</span></span><br><span class="line">        <span class="keyword">const</span> html = <span class="keyword">await</span> renderer.renderToString(&#123;</span><br><span class="line">            <span class="comment">// 在模板中使用外部数据(可选第二个参数)</span></span><br><span class="line">            title:<span class="string">'vue ssr'</span>,</span><br><span class="line">            meta: <span class="string">`&lt;meta name="description" content="vue-SSR"&gt;`</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html; charset=utf-8'</span>)</span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        res.status(<span class="number">500</span>).end(<span class="string">'Internal Server Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由</span></span><br><span class="line">server.get(<span class="string">'/'</span>, isPro</span><br><span class="line">    ? render <span class="comment">// 生产模式：使用构建好的包直接渲染</span></span><br><span class="line">    : <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 等待有了 Renderer 渲染器以后，调用 render 函数</span></span><br><span class="line">        <span class="keyword">await</span> onReady</span><br><span class="line">        render(req, res)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server running at port 3000'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="封装处理模块"><a href="#封装处理模块" class="headerlink" title="封装处理模块"></a>封装处理模块</h4><p><code>build/setup-dev-server.js</code>，开发模式，自动构建，更新 Renderer 渲染器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">file</span> =&gt;</span> path.resolve(__dirname, file)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">server, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ready</span><br><span class="line">    <span class="keyword">const</span> onReady = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> ready = resolve)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监视构建 --&gt; 更新 Renderer</span></span><br><span class="line">    <span class="keyword">let</span> template</span><br><span class="line">    <span class="keyword">let</span> serverBundle</span><br><span class="line">    <span class="keyword">let</span> clientManifest</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update更新函数</span></span><br><span class="line">    <span class="keyword">const</span> update = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 当资源都构建好后，在调用callback，重新生成 Renderer渲染器（server.js）</span></span><br><span class="line">        <span class="keyword">if</span>(template &amp;&amp; serverBundle &amp;&amp; clientManifest)&#123;</span><br><span class="line">            <span class="comment">// 调用callback，意味着开发模式下打包构建成功了，让Promise变为resolve状态，onReady的Promise也就成功了，在server.js中渲染时候(路由)，如果是开发模式就直接onReady，调用render渲染</span></span><br><span class="line">            ready()</span><br><span class="line">            callback(serverBundle, template, clientManifest)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update() <span class="comment">// 初始调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理模板文件：监视构建 template --&gt; 调用 update --&gt; 更新 Renderer 渲染器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端监视打包：监视构建 serverBundle --&gt; 调用 update --&gt; 更新 Renderer 渲染器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端构建：监视构建 clientManifest --&gt; 调用 update --&gt; 更新 Renderer 渲染器</span></span><br><span class="line">    <span class="keyword">return</span> onReady</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理模板文件-监视构建-template"><a href="#处理模板文件-监视构建-template" class="headerlink" title="处理模板文件(监视构建 template)"></a>处理模板文件(监视构建 template)</h5><p>关于 Node 中的监视的问题：</p>
<ul>
<li>fs.watch</li>
<li>fs.watchFile</li>
<li>第三方包：<a href="https://github.com/paulmillr/chokidar" target="_blank" rel="noopener">chokidar</a></li>
</ul>
<p>fs.watch、fs.watchFile不太好使用，推荐使用第三方包 chokidar 监听文件的变化,其内部也是封装了原生的监视模块，性能和功能上比原生好。</p>
<p>安装第三方包：chokidar</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -D chokidar</span><br></pre></td></tr></table></figure>
<p><code>build/setup-dev-server.js</code>，监视构建 template，更新 Renderer 渲染器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理模板文件：监视构建 template -&gt; 调用 update -&gt; 更新 Renderer 渲染器</span></span><br><span class="line">    <span class="keyword">const</span> templatePath = resolve(<span class="string">'../index.html'</span>)  <span class="comment">// 获取模板文件路径</span></span><br><span class="line">    template = fs.readFileSync(templatePath, <span class="string">'utf-8'</span>)  <span class="comment">// 初始获取模板文件内容</span></span><br><span class="line">    update() <span class="comment">// 初始化</span></span><br><span class="line">      <span class="comment">// 监视资源变化，fs.watch、fs.watchFile不太好使用，推荐使用第三方包 chokidar 监听文件的变化</span></span><br><span class="line">      chokidar.watch(templatePath).on(<span class="string">'change'</span>, (event, path) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 文件发生改变后重新获取文件内容，调用update函数更新 Renderer</span></span><br><span class="line">        template = fs.readFileSync(templatePath, <span class="string">'utf-8'</span>)</span><br><span class="line">        update()</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<h5 id="服务端监视打包-监视构建-serverBundle"><a href="#服务端监视打包-监视构建-serverBundle" class="headerlink" title="服务端监视打包(监视构建 serverBundle)"></a>服务端监视打包(监视构建 serverBundle)</h5><p><code>build/setup-dev-server.js</code>，监视构建 serverBundle，更新 Renderer 渲染器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端监视打包：监视构建 serverBundle -&gt; 调用 update -&gt; 更新 Renderer 渲染器</span></span><br><span class="line"><span class="keyword">const</span> serverConfig = <span class="built_in">require</span>(<span class="string">'./webpack.server.config.js'</span>)</span><br><span class="line"><span class="comment">// 使用webpack构建的实例</span></span><br><span class="line"><span class="keyword">const</span> serverCompiler = webpack(serverConfig)</span><br><span class="line">serverCompiler.watch(&#123;</span><br><span class="line">    <span class="comment">// 监视打包的可选配置参数</span></span><br><span class="line">&#125;,(err, stats) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="keyword">if</span>(stats.hasErrors()) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// require 引入的文件有缓存,此处使用读取文件方式（fs读取物理磁盘文件）</span></span><br><span class="line">    serverBundle = <span class="built_in">JSON</span>.parse(fs.readFileSync(resolve(<span class="string">'../dist/vue-ssr-server-bundle.json'</span>), <span class="string">'utf-8'</span>))</span><br><span class="line">    update()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>开发环境频繁的磁盘读写，速度慢，将打包结果存储到内存中，提高速度，如何将打包结果存储到内存中？</p>
<h6 id="将打包结果存储到内存中"><a href="#将打包结果存储到内存中" class="headerlink" title="将打包结果存储到内存中"></a>将打包结果存储到内存中</h6><p>webpack 默认会把构建结果存储到磁盘中，对于生产模式构建来说是没有问题的；但是我们在开发模 式中会频繁的修改代码触发构建，也就意味着要频繁的操作磁盘数据，而磁盘数据操作相对来说是比较慢的，所以我们有一种更好的方式，就是 把数据存储到内存中，这样可以极大的提高构建的速度。两种方式：</p>
<ul>
<li>方案一：自己配置 <a href="https://github.com/streamich/memfs" target="_blank" rel="noopener">memfs</a><br>memfs 是一个兼容 Node 中 fs 模块 API 的内存文件系统，通过它我们可以轻松的实现把 webpack 构建结果输出到内存中进行管理。</li>
</ul>
<ol>
<li>安装第三方包：memfs</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -D memfs</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>build/setup-dev-server.js</code>，监视构建 serverBundle，更新 Renderer 渲染器</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createFsFromVolume, Volume &#125; = <span class="built_in">require</span>(<span class="string">'memfs'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 webpack 把数据写入内存中</span></span><br><span class="line">serverCompiler.outputFileSystem = createFsFromVolume(<span class="keyword">new</span> Volume()) </span><br><span class="line"><span class="comment">// memfs 模块去除了 join 方法，所以这里我们需要手动的给它提供 join 方法</span></span><br><span class="line">serverCompiler.outputFileSystem.join = path.join.bind(path) serverCompiler.watch(&#123;</span><br><span class="line">	<span class="comment">// 监视构建的配置选项</span></span><br><span class="line">&#125;, (err, stats) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 每当构建成功，就会执行该回调函数  </span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (stats.hasErrors()) <span class="keyword">return</span>                    </span><br><span class="line"><span class="comment">// 读取打包之后的最新结果 </span></span><br><span class="line">	serverBundle = <span class="built_in">JSON</span>.parse(</span><br><span class="line">    	serverCompiler.outputFileSystem.readFileSync(resolve(<span class="string">'../dist/vue-ssr-server-bundle.json'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">    )</span><br><span class="line">	<span class="comment">// update 更新  </span></span><br><span class="line">    update()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>方案二：使用 <a href="https://github.com/webpack/webpack-dev-middleware" target="_blank" rel="noopener">webpack-dev-middleware</a></li>
</ul>
<p><code>webpack-dev-middleware</code> 作用是，以监听模式启动 webpack，将编译结果输出到内存中，然后将内存文件输出到 Express 服务中。</p>
<ol>
<li>安装依赖：webpack-dev-middleware</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -D webpack-dev-middleware</span><br></pre></td></tr></table></figure>
<p>2.配置到构建流程中，build/setup-dev-server.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> devMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)</span><br><span class="line"><span class="comment">// 服务端监视打包：监视构建 serverBundle -&gt; 调用 update -&gt; 更新 Renderer 渲染器</span></span><br><span class="line"><span class="keyword">const</span> serverConfig = <span class="built_in">require</span>(<span class="string">'./webpack.server.config.js'</span>)</span><br><span class="line"><span class="comment">// 使用webpack构建的实例</span></span><br><span class="line"><span class="keyword">const</span> serverCompiler = webpack(serverConfig)</span><br><span class="line"><span class="comment">// 把数据存储到内存中，极大的提高构建的速度</span></span><br><span class="line"><span class="comment">// devMiddleware构建完成后不会退出，以监视模式监视资源的变动，从新打包构建和手动调用watch类似</span></span><br><span class="line"><span class="keyword">const</span> serverDevMiddleware = devMiddleware(serverCompiler, &#123;</span><br><span class="line">    <span class="comment">// 配置 webpack-dev-middleware ^3.7.2 选项</span></span><br><span class="line">    logLevel: <span class="string">'silent'</span> <span class="comment">// 关闭日志输出 ，由 FriendlyErrorsWebpackPlugin（webpack.base.config.js） 处理</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// done表示当每次编译结束的时候都会触发钩子</span></span><br><span class="line"><span class="comment">// 参数1：插件名</span></span><br><span class="line">serverCompiler.hooks.done.tap(<span class="string">'server'</span>, ()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 读取内存中的文件</span></span><br><span class="line">    <span class="comment">// serverDevMiddleware.fileSystem 获取到devMiddleware内部操作文件系统的对象，相当于nodejs中的fs</span></span><br><span class="line">    serverBundle = <span class="built_in">JSON</span>.parse(</span><br><span class="line">        serverDevMiddleware.fileSystem.readFileSync(resolve(<span class="string">'../dist/vue-ssr-server-bundle.json'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">        )</span><br><span class="line">    update()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="客户端构建-监视构建-clientManifest"><a href="#客户端构建-监视构建-clientManifest" class="headerlink" title="客户端构建(监视构建 clientManifest)"></a>客户端构建(监视构建 clientManifest)</h5><p>客户端打包和服务端打包类似，都是借助于 <code>webpack-dev-middleware</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> devMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)</span><br><span class="line"><span class="comment">// 客户端构建：监视构建 clientManifest -&gt; 调用 update -&gt; 更新 Renderer 渲染器</span></span><br><span class="line"><span class="keyword">const</span> clientConfig = <span class="built_in">require</span>(<span class="string">'./webpack.client.config.js'</span>)</span><br><span class="line"><span class="comment">// webpack构建实例</span></span><br><span class="line"><span class="keyword">const</span> clientCompiler = webpack(clientConfig)</span><br><span class="line"><span class="keyword">const</span> clientDevMiddleware = devMiddleware(clientCompiler, &#123;</span><br><span class="line">    <span class="comment">// 重要！输出资源的访问路径前缀，应该和 客户端打包输出的 publicPath 一致</span></span><br><span class="line">    publicPath:clientConfig.output.publicPath,</span><br><span class="line">    logLevel: <span class="string">'silent'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用钩子，注册插件</span></span><br><span class="line">clientCompiler.hooks.done.tap(<span class="string">'client'</span>, ()=&gt;&#123;</span><br><span class="line">     <span class="comment">// fileSystem 获取内部操作文件系统的对象 类似 NodeJS 的 fs（操纵磁盘中的文件）</span></span><br><span class="line">    clientManifest = <span class="built_in">JSON</span>.parse(</span><br><span class="line">        clientDevMiddleware.fileSystem.readFileSync(resolve(<span class="string">'../dist/vue-ssr-client-manifest.json'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">        )</span><br><span class="line">    update()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 重要！！！将 clientDevMiddleware 挂载到 Express 服务中，提供对其内部内存中数据的访问</span></span><br><span class="line">server.use(clientDevMiddleware)</span><br></pre></td></tr></table></figure>
<h5 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h5><p>热更新功能需要使用到 <a href="https://github.com/webpack-contrib/webpack-hot-middleware" target="_blank" rel="noopener">webpack-hot-middleware</a> 工具包</p>
<ul>
<li>安装依赖</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev webpack-hot-middleware</span><br></pre></td></tr></table></figure>
<ul>
<li><code>build/setup-dev-server.js</code> 配置热更新</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> devMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)</span><br><span class="line"><span class="keyword">const</span> hotMiddleware = <span class="built_in">require</span>(<span class="string">"webpack-hot-middleware"</span>)</span><br><span class="line"><span class="comment">// 客户端构建：监视构建 clientManifest -&gt; 调用 update -&gt; 更新 Renderer 渲染器</span></span><br><span class="line"><span class="keyword">const</span> clientConfig = <span class="built_in">require</span>(<span class="string">'./webpack.client.config.js'</span>)</span><br><span class="line"><span class="comment">// ======================== 配置热更新 ======================== </span></span><br><span class="line"><span class="comment">// 使用webpack-hot-middleware实现热更新（https://github.com/webpack-contrib/webpack-hot-middleware）</span></span><br><span class="line">clientConfig.plugins.push(<span class="keyword">new</span> webpack.HotModuleReplacementPlugin())</span><br><span class="line">clientConfig.entry.app = [</span><br><span class="line">    <span class="string">'webpack-hot-middleware/client?quiet=true&amp;reload=true'</span>, <span class="comment">// 和服务端交互处理热更新一个客户端脚本</span></span><br><span class="line">    clientConfig.entry.app <span class="comment">// 本来的脚本</span></span><br><span class="line">]</span><br><span class="line">clientConfig.output.filename = <span class="string">'[name].js'</span> <span class="comment">// 热更新模式下确保hash一致</span></span><br><span class="line"><span class="comment">// ========================/ 配置热更新 ======================== </span></span><br><span class="line"><span class="comment">//  webpack构建实例</span></span><br><span class="line"><span class="keyword">const</span> clientCompiler = webpack(clientConfig)</span><br><span class="line"><span class="keyword">const</span> clientDevMiddleware = devMiddleware(clientCompiler, &#123;</span><br><span class="line">    <span class="comment">// 重要！输出资源的访问路径前缀，应该和 客户端打包输出的 publicPath 一致</span></span><br><span class="line">    publicPath:clientConfig.output.publicPath,</span><br><span class="line">    <span class="comment">// 关闭日志输出，由 FriendlyErrorsWebpackPlugin 处理</span></span><br><span class="line">    logLevel: <span class="string">'silent'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 调用钩子，注册插件</span></span><br><span class="line">clientCompiler.hooks.done.tap(<span class="string">'client'</span>, ()=&gt;&#123;</span><br><span class="line">     <span class="comment">// fileSystem 获取内部操作文件系统的对象 类似 NodeJS 的 fs（操纵磁盘中的文件）</span></span><br><span class="line">    clientManifest = <span class="built_in">JSON</span>.parse(</span><br><span class="line">        clientDevMiddleware.fileSystem.readFileSync(resolve(<span class="string">'../dist/vue-ssr-client-manifest.json'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line">        )</span><br><span class="line">    update()</span><br><span class="line">&#125;)</span><br><span class="line">server.use(hotMiddleware(clientCompiler, &#123;</span><br><span class="line">    log: <span class="literal">false</span> <span class="comment">// 关闭热更新本身的日志输出</span></span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// 重要！！！将 clientDevMiddleware 挂载到 Express 服务中，提供对其内部内存中数据的访问</span></span><br><span class="line">server.use(clientDevMiddleware)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>工作原理：</p>
<p>中间件将自身安装为 webpack 插件，并侦听编译器事件。<br>每个连接的客户端都有一个 Server Sent Events 连接，服务器将在编译器事件上向连接的客户端 发布通知。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">MDN - 使用服务器发送事件</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">Server-Sent Events 教程</a><br>当客户端收到消息时，它将检查本地代码是否为最新。如果不是最新版本，它将触发 webpack 热更新模块重新加载。</p>
<h2 id="编写通用代码"><a href="#编写通用代码" class="headerlink" title="编写通用代码"></a><a href="https://ssr.vuejs.org/zh/guide/universal.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94" target="_blank" rel="noopener">编写通用代码</a></h2><p>到此为止我们终于把实现 Vue SSR 同构应用的基础环境搭建起来，虽然还有很多不足之处，但是也能满足我们当前的基本使用了。接下来把内容的核心转移到 Vue SSR 本身上，了解一下编写通用应用的注意事项，对于如何正确的使用 Vue SSR 是非常有帮助的。</p>
<p>在这些注意事项中，有些其实已经在前面的学习过程中了解过了，而有些还没有接触过，所以在这里通 过官方文档做一个简单的总结</p>
<h3 id="服务器上的数据相应"><a href="#服务器上的数据相应" class="headerlink" title="服务器上的数据相应"></a>服务器上的数据相应</h3><p>在纯客户端应用程序 (client-only app) 中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染 (cross-request state pollution),例如 app.js 代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出一个工厂函数，用于创建新的应用程序、router、store实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建实例的代码放在函数中，每次请求进来，或者有不同的用户调用函数创建一个独立的vue实例处理请求，不会出现类似于状态污染的问题</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// 根实例简单的渲染应用程序</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; app &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果所有请求都共享了同一个vue实例，会造成状态的交叉污染</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>因为实际的渲染过程需要确定性，所以我们也将在服务器上“预取”数据 (“pre-fetching” data) - 这意味着在我们开始渲染时，我们的应用程序就已经解析完成其状态。也就是说，将数据进行响应式的过程在服务器上是多余的，所以默认情况下禁用。禁用响应式数据，还可以避免将「数据」转换为「响应式对象」的性能开销。</p>
<h3 id="组件生命周期钩子函数"><a href="#组件生命周期钩子函数" class="headerlink" title="组件生命周期钩子函数"></a>组件生命周期钩子函数</h3><p>由于没有动态更新，所有的生命周期钩子函数中，只有 beforeCreate 和 created 会在服务器端渲染 (SSR) 过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 beforeMount 或 mounted），只会在客户端执行。</p>
<p>此外还需要注意的是，你应该避免在 beforeCreate 和 created 生命周期时产生全局副作用的代码，例如在其中使用 setInterval 设置 timer。在纯客户端 (client-side only) 的代码中，我们可以设置一个 timer，然后在 beforeDestroy 或 destroyed 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，请将副作用代码移动到 beforeMount 或 mounted 生命周期中。</p>
<h3 id="访问特定平台-Platform-Specific-API"><a href="#访问特定平台-Platform-Specific-API" class="headerlink" title="访问特定平台(Platform-Specific) API"></a>访问特定平台(Platform-Specific) API</h3><p>通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 window 或 document，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。</p>
<p>对于共享于服务器和客户端，但用于不同平台 API 的任务(task)，建议将平台特定实现包含在通用 API 中，或者使用为你执行此操作的 library。例如，<a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a> 是一个 HTTP 客户端，可以向服务器和客户端都暴露相同的 API。</p>
<p>对于仅浏览器可用的 API，通常方式是，在「纯客户端 (client-only)」的生命周期钩子函数中惰性访问 (lazily access) 它们。</p>
<p>请注意，考虑到如果第三方 library 不是以上面的通用用法编写，则将其集成到服务器渲染的应用程序中，可能会很棘手。你可能要通过模拟 (mock) 一些全局变量来使其正常运行，但这只是 hack 的做法，并且可能会干扰到其他 library 的环境检测代码。</p>
<h3 id="区分运行环境"><a href="#区分运行环境" class="headerlink" title="区分运行环境"></a>区分运行环境</h3><p><a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener">webpack DefinePlugin</a><br>区分运行环境:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;  </span><br><span class="line">    <span class="string">'process.client'</span>: <span class="literal">true</span>,  </span><br><span class="line">    <span class="string">'process.server'</span>: <span class="literal">false</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>大多数自定义指令直接操作 DOM，因此会在服务器端渲染 (SSR) 过程中导致错误。有两种方法可以解决这个问题：</p>
<ul>
<li>推荐使用组件作为抽象机制，并运行在「虚拟 DOM 层级(Virtual-DOM level)」（例如，使用渲染函数(render function)）。</li>
<li>如果你有一个自定义指令，但是不是很容易替换为组件，则可以在创建服务器 renderer 时，使用 directives 选项所提供”服务器端版本(server-side version)”</li>
</ul>
<h2 id="路由和代码分割"><a href="#路由和代码分割" class="headerlink" title="路由和代码分割"></a><a href="https://ssr.vuejs.org/zh/guide/routing.html#%E4%BD%BF%E7%94%A8-vue-router-%E7%9A%84%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">路由和代码分割</a></h2><p>接下来我们来了解如何处理通用应用中的路由,和纯客户端的使用方式基本一致，使用vue-router,只需要在少许的位置做一些配置即可。通过查看文档来具体演示下:</p>
<h3 id="配置VueRouter-router-index-js"><a href="#配置VueRouter-router-index-js" class="headerlink" title="配置VueRouter - router/index.js"></a>配置VueRouter - router/index.js</h3><ul>
<li>安装</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router</span><br></pre></td></tr></table></figure>
<ul>
<li>配置 VueRouter (路由规则)<code>router/index.js</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> vueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="comment">// webpack中配置@指向src</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'@/pages/Home'</span></span><br><span class="line"></span><br><span class="line">Vue.use(vueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRouter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vueRouter(&#123;</span><br><span class="line">    <span class="comment">// 同构应用不能使用 hash 路由，应该使用 history 模式，兼容前后端</span></span><br><span class="line">    mode: <span class="string">'history'</span>,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/'</span>,</span><br><span class="line">            name: <span class="string">'Home'</span>,</span><br><span class="line">            component: Home</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            path: <span class="string">'/about'</span>,</span><br><span class="line">            name: <span class="string">'About'</span>,</span><br><span class="line">             <span class="comment">// 懒加载路由 按需加载，异步的</span></span><br><span class="line">            component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/pages/About'</span>)</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            path: <span class="string">'/posts'</span>,</span><br><span class="line">            name: <span class="string">'Posts'</span>,</span><br><span class="line">            component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/pages/Posts'</span>)</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            path: <span class="string">'*'</span>,</span><br><span class="line">            name: <span class="string">'error404'</span>,</span><br><span class="line">            component: <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'@/pages/404'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将路由注册到根实例"><a href="#将路由注册到根实例" class="headerlink" title="将路由注册到根实例"></a>将路由注册到根实例</h3><ul>
<li>注册路由 <code>src/app.js</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用 entry</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个工厂函数，用于创建新的</span></span><br><span class="line"><span class="comment">// 应用程序、router 和 store 实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建router实例</span></span><br><span class="line">  <span class="keyword">const</span> router = createRouter()</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// 注入router到根vue实例</span></span><br><span class="line">    router,</span><br><span class="line">    <span class="comment">// 根实例简单的渲染应用程序组件。</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 返回app和router</span></span><br><span class="line">  <span class="keyword">return</span> &#123; app, router&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适配服务端入口"><a href="#适配服务端入口" class="headerlink" title="适配服务端入口"></a>适配服务端入口</h3><ul>
<li><code>entry-server.js</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端启动入口</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 官方示例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="comment">// 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise，</span></span><br><span class="line">    <span class="comment">// 以便服务器能够等待所有的内容在渲染前，就已经准备就绪。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app, router &#125; = createApp()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器端 router 的位置（服务端渲染时候这个过程是看不到）</span></span><br><span class="line">    router.push(context.url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等到 router 将可能的异步组件和钩子函数解析完</span></span><br><span class="line">    router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/* 在router中有配置404情况，此处代码可以省略</span></span><br><span class="line"><span class="comment">      // 获取匹配路由的组件</span></span><br><span class="line"><span class="comment">      const matchedComponents = router.getMatchedComponents()</span></span><br><span class="line"><span class="comment">      // 匹配不到的路由，执行 reject 函数，并返回 404</span></span><br><span class="line"><span class="comment">      if (!matchedComponents.length) &#123;</span></span><br><span class="line"><span class="comment">        // 这样处理就可以在server中获取到状态码，进行404的处理  </span></span><br><span class="line"><span class="comment">        return reject(&#123; code: 404 &#125;)</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Promise 应该 resolve 应用程序实例，以便它可以渲染</span></span><br><span class="line">      resolve(app)</span><br><span class="line">    &#125;, reject)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用async/await改造上述代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app, router,store &#125; = createApp()</span><br><span class="line">    <span class="keyword">const</span> meta = app.$meta()</span><br><span class="line">    <span class="comment">// 用于设置服务器端router的位置</span></span><br><span class="line">    router.push(context.url)</span><br><span class="line">    context.meta = meta</span><br><span class="line">    <span class="comment">// this的指向router</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(router.onReady.bind(router))</span><br><span class="line">    context.rendered = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Renderer 会把 context.state 数据对象内联到页面模板中</span></span><br><span class="line">    <span class="comment">// 最终发送给客户端的页面中会包含一段脚本：window.__INITIAL_STATE__ = context.state</span></span><br><span class="line">    <span class="comment">// 客户端就要把页面中的 window.__INITIAL_STATE__ 拿出来填充到客户端 store 容器中</span></span><br><span class="line">        context.state = store.state</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// async对于非Promise的数据，会将他把装在Promise中，成功后返回对应的数据</span></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务端适配"><a href="#服务端适配" class="headerlink" title="服务端适配"></a>服务端适配</h3><ul>
<li>进行服务端 server 适配 <code>server.js</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> render = <span class="keyword">async</span> (req, res) =&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// renderToString支持promise</span></span><br><span class="line">        <span class="keyword">const</span> html = <span class="keyword">await</span> renderer.renderToString(&#123;</span><br><span class="line">            <span class="comment">// 在模板中使用外部数据(可选第二个参数)</span></span><br><span class="line">            title:<span class="string">'vue ssr'</span>,</span><br><span class="line">            meta: <span class="string">`&lt;meta name="description" content="vue-SSR"&gt;`</span>,</span><br><span class="line">            <span class="comment">// entry-server.js用于设置服务器端router的位置</span></span><br><span class="line">            url: req.url</span><br><span class="line">        &#125;)</span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/html; charset=utf-8'</span>)</span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        res.status(<span class="number">500</span>).end(<span class="string">'Internal Server Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由</span></span><br><span class="line"><span class="comment">// 服务端路由设置为 *，意味着所有的路由都会进入这里</span></span><br><span class="line">server.get(<span class="string">'*'</span>,isPro </span><br><span class="line">    ? render <span class="comment">// 生产模式下可以直接使用renderer</span></span><br><span class="line">    : <span class="keyword">async</span> (req, res)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 开发模式下需要先打包构建，在使用renderer进行处理</span></span><br><span class="line">    <span class="comment">// 等待有了 Renderer 渲染器以后，调用 render 进行渲染</span></span><br><span class="line">    <span class="keyword">await</span> onReady</span><br><span class="line">    render(req, res)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="适配客户端入口"><a href="#适配客户端入口" class="headerlink" title="适配客户端入口"></a>适配客户端入口</h3><p>路由器必须要提前解析路由配置中的异步组件，才能正确地调用组件中可能存在的路由钩子。</p>
<p><code>entry-client.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"><span class="comment">// 客户端特定引导逻辑</span></span><br><span class="line"><span class="keyword">const</span> &#123; app, router&#125; = createApp()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="配置路由出口"><a href="#配置路由出口" class="headerlink" title="配置路由出口"></a>配置路由出口</h3><p>根组件中，设置路由的出口<code>src/App.vue</code>,如果没有路由出口的话，匹配到的路由组件就不知道要渲染到哪里</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;router-link to=<span class="string">'/'</span>&gt;Home&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;router-link to=<span class="string">'/about'</span>&gt;About&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;router-link to=<span class="string">"/posts"</span>&gt;Posts&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;!-- 路由出口 --&gt;</span></span><br><span class="line"><span class="regexp">        &lt;router-view/</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"App"</span></span><br><span class="line">    &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>到此位置路由相关配置已经完成，可以启动项目测试</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>测试路由导航，可以看到正常工作，那说明我们同构应用中的路由产生作用了。</p>
<p>现在我们的应用就非常的厉害了，当你首次访问页面的时候，它是通过服务端渲染出来的，服务端渲染拥有了更快的渲染速度以及更好的 SEO，当服务端把渲染的内容发送到客户端后，客户端通过 Vue 结合 Vue Router 把当前内容激活，摇身一变成为了一个客户端单页面 SPA 应用，之后的页面导航交互是通过客户端交互的方式处理，不需要重新刷新整个页面。这样我们的网站就既拥有了更好的渲染速度和SEO，也拥有了单页应用中更好的用户体验。</p>
<p>除此之外，我们在路由中配置的异步组件（也叫路由懒加载）也是非常有意义，这些异步组件会被分割为独立的 chunk（也就是单独的文件），只有在需要的时候才会进行加载。这样就能够避免在初始渲染的时候客户端加载的脚本过大导致激活速度变慢的问题。</p>
<p>我们可以来验证一下，通过 <code>npm run build</code> 打包构建，我们发现它们确实被分割成了独立的 chunk ，如下图所示：</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr11.png" alt="dist"></p>
<p>然后再来看一下在运行期间这些chunk文件是如何加载的</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr12.png" alt="dist"></p>
<p>我们会发现除了 app 主资源外，其它的资源也被下载下来了，这里可能会有个疑问：不是应该在需要的时候才加载吗？为什么一上来就加载了？</p>
<p>原因是在页面的头部中的带有 preload 和 prefetch 的 link 标签</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr13.png" alt="dist"></p>
<p>我们期望客户端 JavaScript 脚本尽快加载尽早的接管服务端渲染的内容，让其拥有动态交互能力，但是如果把这些资源以 script 标签替代 link 标签这里这里的话，浏览器会去下载它，然后执行里面的代码，这个过程会阻塞页面的渲染。所以看到真正的 script 标签是在页面的底部的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"/dist/app.js"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"/dist/0.js"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"/dist/1.js"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"/dist/2.js"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这部分代码是告诉浏览器可以去预加载这个资源。但是不要执行里面的代码，也不要影响网页的正常渲染。直到遇到真正的 script 标签加载该资源的时候才会去执行里面的代码，这个时候可能已经预加载好了，直接使用就可以了，如果没有加载好，也不会造成重复加载，所以不用担心这个问题。</p>
<ul>
<li>prefetch 资源是加载下一个页面可能用到的资源，浏览器会在空闲的时候对其进行加载，所以它并不一定会把资源加载出来</li>
<li><p>preload 当前页面一定会用到的资源，对其进行预加载。所以当我们去访问 about 页面的时候，它的资源是通过 prefetch 预取过来的（prefetch不稳定，页面的js可能是其加载好的），提高了客户端页面导航的响应速度。</p>
<p><img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr14.png" alt="dist"></p>
</li>
</ul>
<h2 id="管理页面-Head"><a href="#管理页面-Head" class="headerlink" title="管理页面 Head"></a>管理页面 Head</h2><p>无论是服务端渲染还是客户端渲染，它们都使用的同一个页面模板。页面中的 body 是动态渲染出来的，但是页面的 head 是写死的，如果我们希望不同的页面可以拥有自己的 head 内容，例如页面的 title、meta 等内容，如何处理呢？ 下面我们来了解一下如何让不同的页面来定制自己的 head 头部内容。</p>
<p>官方文档这里专门描述了关于页面 <a href="https://ssr.vuejs.org/zh/guide/head.html" target="_blank" rel="noopener">Head</a> 的处理，相对于来讲更原生一些，使用比较麻烦，有兴趣的同学可以了解一下。</p>
<p>我这里主要给大家介绍一个第三方解决方案：<a href="https://vue-meta.nuxtjs.org/guide/" target="_blank" rel="noopener">vue-meta</a></p>
<p>Vue Meta 是一个支持 SSR 的第三方 Vue.js 插件，可让你轻松的实现不同页面的 head 内容管理。 使用它的方式非常简单，而只需在页面组件中使用 <strong>metaInfo</strong> 属性配置页面的 head 内容即可。</p>
<p>使用 vue-meta 进行配置具体步骤如下：</p>
<ul>
<li>安装 vue-meta 依赖</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D vue-meta</span><br></pre></td></tr></table></figure>
<ul>
<li>在通用入口 <code>app.js</code> 中通过插件的方式将 vue-meta 注册到 Vue 中</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> VueMeta <span class="keyword">from</span> <span class="string">'vue-meta'</span></span><br><span class="line"><span class="comment">// 注册插件</span></span><br><span class="line">Vue.use(VueMeta)</span><br><span class="line"></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  metaInfo:&#123;</span><br><span class="line">    <span class="comment">// 混入选项 %s 为用户自定义数据</span></span><br><span class="line">    titleTemplate:<span class="string">'%s - vue SSR'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>在服务端渲染入口 <code>src/entry-server.js</code> 模块中适配 vue-meta</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> context =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app, router &#125; = createApp()</span><br><span class="line">    <span class="keyword">const</span> meta = app.$meta()</span><br><span class="line">    <span class="comment">// 设置服务端router位置</span></span><br><span class="line">    router.push(context.url)</span><br><span class="line">    context.meta = meta</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在模板页面index.html中注入 meta 信息</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公共内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 动态注入的内容 --&gt;</span></span><br><span class="line">    &#123;&#123;&#123; meta.inject().title.text() &#125;&#125;&#125;</span><br><span class="line">    &#123;&#123;&#123; meta.inject().meta.text() &#125;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>组件(src/pages/Home.vue) 中，配置 metaInfo</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'HomePage'</span>,</span><br><span class="line">  metaInfo: &#123;</span><br><span class="line">    title: <span class="string">'首页'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>页面显示效果如下所示</p>
<p><img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr15.png" alt="dist"></p>
</li>
</ul>
<h2 id="数据预取和状态管理"><a href="#数据预取和状态管理" class="headerlink" title="数据预取和状态管理"></a>数据预取和状态管理</h2><p>接下来我们来了解一下服务端渲染中的数据预取和状态管理。<br><a href="https://ssr.vuejs.org/zh/guide/data.html" target="_blank" rel="noopener">官方文档</a>中的描述比较枯燥，无法在很短的时间内搞清楚它到底要做什么，所以我们这里通过一个实际的业务需求来引入这个话题。<br>我们的需求就是：</p>
<ul>
<li>已知有一个数据接口，接口返回一个文章列表数据</li>
<li>我们想要通过服务端渲染的方式来把异步接口数据渲染到页面中</li>
</ul>
<p>这个需求看起来是很简单,无非就是在页面发请求拿数据，然后在模板中遍历出来，如果是纯客户端渲染的话确实就是这样的，但是想要通过服务端渲染的方式来处理的话就比较麻烦了，下面我们来具体实现下</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr16.png" alt="dist"></p>
<p>也就是说我们要在服务端获取异步接口数据(url:<code>https://cnodejs.org/api/v1/topics</code>)，交给 Vue 组件去渲染。我们首先想到的是在组件的生命周期钩子中请求获取数据渲染页面，既在组件中添加生命周期钩子beforeCreate 和 created（服务端渲染仅支持这两个钩子函数的调用）。</p>
<p>那么下一个问题是如何在服务端发送请求？<br>依然使用 axios，axios 既可以运行在客户端也可以运行在服务端，因为它对不同的环境做了适配处理，在客户端是基于浏览器的 XMLHttpRequest 请求对象，在服务端是基于 Node.js 中的 http 模块实现，无论是底层是什么，上层的使用方式都是一样的，具体代码如下：</p>
<p><code>src/pages/Post.vue</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;PostList&apos;,</span><br><span class="line">  metaInfo: &#123;</span><br><span class="line">    title: &apos;Posts&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      posts: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line"> // beforeCreate是获取不到data中的数据，所以将请求放到created中</span><br><span class="line"> // 服务端渲染只支持 beforeCreate 和 created，不会等待 beforeCreate 和 created 中的异步操作，这种做法在服务端渲染中是不会工作的</span><br><span class="line">  async created () &#123;</span><br><span class="line">    console.log(&apos;Posts Created Start&apos;)</span><br><span class="line">    const &#123; data &#125; = await axios(&#123;</span><br><span class="line">      method: &apos;GET&apos;,</span><br><span class="line">      url: &apos;https://cnodejs.org/api/v1/topics&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 不支持响应式数据</span><br><span class="line">    this.posts = data.data</span><br><span class="line">    console.log(&apos;Posts Created End&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上述代码的这种做法只会在客户端工作，在服务端渲染中是不会工作的，原因是因为：服务端渲染期间确实会调用created生命周期钩子函数，但是他不会等待其中的异步操作，即便是可以获取到接口返回的异步数据，服务端也不支持这种响应式的操作。</p>
<p>我们可以来验证下，上述代码的运行结果如下：</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr18.png" alt="dist"></p>
<p>在浏览中展示的内容并不是通过服务端渲染过来，服务端返回的内容没有列表数据，列表的数据是通过后期客户端方式加载进来的</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr19.png" alt="dist"></p>
<p>这里可能会有个疑问，created 是不是在服务端没有调用呢？</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr17.png" alt="dist"></p>
<p>通过打印日志可以看到，created 在服务端确实被调用执行了，只是没有作用。</p>
<p>接下来的问题就是：如果我们希望服务端渲染的时候就拿到数据，渲染后的结果就是完整的页面该怎么实现呢？</p>
<p>官方文档给出的解决办法：为了解决这个问题，获取的数据需要位于视图组件之外，即放置在专门的数据预取存储容器(data store)或”状态容器(state container)”中。首先，在服务器端，我们可以在渲染之前预取数据，并将数据填充到 store 中。此外，我们将在 HTML 中序列化(serialize)和内联预置(inline)状态。这样，在挂载(mount)到客户端应用程序之前，可以直接从 store 获取到内联预置(inline)状态。</p>
<p>简单来说：它的核心思路就是把在服务端渲染期间获取的数据存储到外部容器 Vuex 中，然后把容器中的数据同步到客户端，这样就保持了前后端渲染的数据状态同步，避免了客户端重新渲染的问题，所以接下来要做的第一件事就是基于 Vuex 创建容器。</p>
<h3 id="数据预取"><a href="#数据预取" class="headerlink" title="数据预取"></a>数据预取</h3><ol>
<li>通过 Vuex 创建容器实例，并挂载到 Vue 根实例</li>
</ol>
<ul>
<li>安装 vuex</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install vuex</span><br></pre></td></tr></table></figure>
<ul>
<li>创建 Vuex 容器 store/index.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore =  <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">        state:&#123;</span><br><span class="line">            <span class="comment">// 避免交叉污染</span></span><br><span class="line">            posts:[]</span><br><span class="line">        &#125;,</span><br><span class="line">        actions: &#123;</span><br><span class="line">         <span class="comment">// 在服务端渲染期间务必让 action 返回一个 Promise</span></span><br><span class="line">         <span class="comment">// async 默认返回 Promise</span></span><br><span class="line">          <span class="keyword">async</span> getPosts(&#123;commit&#125;)&#123;</span><br><span class="line">              <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.get(<span class="string">'https://cnodejs.org/api/v1/topics'</span>)</span><br><span class="line">              commit(<span class="string">'setPost'</span>, data.data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mutations: &#123;</span><br><span class="line">            setPost(state , data)&#123;</span><br><span class="line">                state.posts = data</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 app.js 中将 Vuex 容器挂载到 Vue 根实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用 entry</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'./store/index'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个工厂函数，用于创建新的</span></span><br><span class="line"><span class="comment">// 应用程序、router 和 store 实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = createStore ()</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// 注入router到根vue实例</span></span><br><span class="line">    router,</span><br><span class="line">    <span class="comment">// 把容器挂载到 Vue 根实例中</span></span><br><span class="line">    store,</span><br><span class="line">    <span class="comment">// 根实例简单的渲染应用程序组件。</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 返回app和router,store实例</span></span><br><span class="line">  <span class="keyword">return</span> &#123; app, router, store&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在组件中使用 serverPrefetch 触发容器中的 action</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Post List&lt;/h1&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;post in posts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapState, mapActions &#125; from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([&apos;posts&apos;])</span><br><span class="line">  &#125;,</span><br><span class="line">  // Vue SSR 特殊为服务端渲染提供的一个生命周期钩子函数(渲染之前调用)</span><br><span class="line">  serverPrefetch () &#123;</span><br><span class="line">    // 发起 action，返回 Promise</span><br><span class="line">    // this.$store.dispatch(&apos;getPosts&apos;)</span><br><span class="line">    return this.getPosts()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([&apos;getPosts&apos;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr20.png" alt="dist"></p>
<p>通运行结果可以看出服务端渲染的页面中存在列表数据，但是浏览器中却没有展示出来，原因是因为此时我们拿到的数据只是存储在了服务端的 Vuex 容器当中了，并没有把数据同步到客户端的 Vuex 容器当中，导致两个端数据不同步，合并失败从而使得客户端重新渲染。</p>
<h3 id="将预取数据同步到客户端"><a href="#将预取数据同步到客户端" class="headerlink" title="将预取数据同步到客户端"></a>将预取数据同步到客户端</h3><ol>
<li>在服务端渲染应用入口中将容器状态序列化到页面中</li>
</ol>
<p>接下来我们要做的就是把在服务端渲染期间所获取填充到容器中的数据同步到客户端容器中，从而避免两个端状态不一致导致客户端重新渲染的问题。</p>
<ul>
<li>将容器中的 state 转为 JSON 格式字符串</li>
<li>生成代码： window.<strong>INITIAL</strong>STATE = 容器状态 语句插入模板页面中</li>
<li>客户端通过 window.<strong>INITIAL</strong>STATE 获取该数据</li>
</ul>
<p>具体实现如下：</p>
<ul>
<li>src/entry-server.js</li>
</ul>
<p>服务端渲染的入口中在router 将可能的异步组件和钩子函数解析完之后增加代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, router,store &#125; = createApp()</span><br><span class="line"> <span class="comment">// 服务端渲染完毕后被调用，当被调用时候也就可以拿到服务端渲染好的容器状态数据</span></span><br><span class="line">context.rendered = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Renderer 会把 context.state 数据对象内联到页面模板中</span></span><br><span class="line"><span class="comment">// 最终发送给客户端的页面中会包含一段脚本：window.__INITIAL_STATE__ = context.state</span></span><br><span class="line"><span class="comment">// 客户端就要把页面中的 window.__INITIAL_STATE__ 拿出来填充到客户端 store 容器中</span></span><br><span class="line">    context.state = store.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这步之后，我们所设置的容器 state 被内联到了模板中，通过这种方式传递给客户端</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr21.png" alt="dist"></p>
<ol start="2">
<li>在客户端渲染入口中把服务端传递过来的状态数据填充到客户端 Vuex 容器中</li>
</ol>
<ul>
<li>src/entry-client.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端启动入口</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端特定引导逻辑……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, router, store&#125; = createApp()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__INITIAL_STATE__) &#123;</span><br><span class="line">    <span class="comment">// 替换容器的数据状态</span></span><br><span class="line">    store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最终运行结果：</p>
<p> <img src="/2021/03/26/【服务器端渲染】-- Vue-SSR/ssr22.png" alt="dist"></p>
<p>服务端渲染好内容后，客户端不在重新渲染，而是接管服务器渲染好的动态的内容交互，客户端通过服务端传递进来的 <code>window.__INITIAL__STATE</code> 将数据同步到客户端的 <code>Vuex</code> 中，数据状态和服务端保持一致，那么也可以在客户端修改数据内容。</p>
<p><a href="https://github.com/Eline302/my-vueSSR" target="_blank" rel="noopener">项目源码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket</a><br><a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">Vue SSR 指南</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SSR/" rel="tag"># SSR</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/16/NuxtJS项目本地部署和自动化部署/" rel="next" title="NuxtJS项目本地部署和自动化部署">
                <i class="fa fa-chevron-left"></i> NuxtJS项目本地部署和自动化部署
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/05/02/前端页面的生命周期/" rel="prev" title="前端页面的生命周期">
                前端页面的生命周期 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/cat.jpg" alt="Eline">
            
              <p class="site-author-name" itemprop="name">Eline</p>
              <p class="site-description motion-element" itemprop="description">Web前端开发</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Eline302" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-SSR-介绍"><span class="nav-number">1.</span> <span class="nav-text">Vue SSR 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是服务器端渲染-SSR"><span class="nav-number">1.1.</span> <span class="nav-text">什么是服务器端渲染 (SSR)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">1.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现-Vue-SSR"><span class="nav-number">1.3.</span> <span class="nav-text">如何实现 Vue SSR</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-SSR-基本使用"><span class="nav-number">2.</span> <span class="nav-text">Vue SSR 基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染一个-Vue-实例"><span class="nav-number">2.1.</span> <span class="nav-text">渲染一个 Vue 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与服务器集成"><span class="nav-number">2.2.</span> <span class="nav-text">与服务器集成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用一个页面模板"><span class="nav-number">2.3.</span> <span class="nav-text">使用一个页面模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建同构渲染-构建流程"><span class="nav-number">3.</span> <span class="nav-text">构建同构渲染 - 构建流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建同构渲染-源码结构"><span class="nav-number">4.</span> <span class="nav-text">构建同构渲染 - 源码结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#App-vue"><span class="nav-number">4.1.</span> <span class="nav-text">App.vue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#app-js"><span class="nav-number">4.2.</span> <span class="nav-text">app.js</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#entry-client-js"><span class="nav-number">4.3.</span> <span class="nav-text">entry-client.js</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#entry-server-js"><span class="nav-number">4.4.</span> <span class="nav-text">entry-server.js</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建同构渲染-构建配置"><span class="nav-number">5.</span> <span class="nav-text">构建同构渲染 - 构建配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装依赖"><span class="nav-number">5.1.</span> <span class="nav-text">安装依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置文件及打包命令"><span class="nav-number">5.2.</span> <span class="nav-text">配置文件及打包命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动应用"><span class="nav-number">5.3.</span> <span class="nav-text">启动应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析渲染流程"><span class="nav-number">5.4.</span> <span class="nav-text">解析渲染流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#服务端渲染"><span class="nav-number">5.4.1.</span> <span class="nav-text">服务端渲染</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端渲染"><span class="nav-number">5.4.2.</span> <span class="nav-text">客户端渲染</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建同构渲染-构建配置开发模式"><span class="nav-number">6.</span> <span class="nav-text">构建同构渲染 - 构建配置开发模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本思路"><span class="nav-number">6.1.</span> <span class="nav-text">基本思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#配置启动脚本package-json"><span class="nav-number">6.1.1.</span> <span class="nav-text">配置启动脚本package.json</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务端配置-server-js"><span class="nav-number">6.1.2.</span> <span class="nav-text">服务端配置 server.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装处理模块"><span class="nav-number">6.1.3.</span> <span class="nav-text">封装处理模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#处理模板文件-监视构建-template"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">处理模板文件(监视构建 template)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#服务端监视打包-监视构建-serverBundle"><span class="nav-number">6.1.3.2.</span> <span class="nav-text">服务端监视打包(监视构建 serverBundle)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#将打包结果存储到内存中"><span class="nav-number">6.1.3.2.1.</span> <span class="nav-text">将打包结果存储到内存中</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#客户端构建-监视构建-clientManifest"><span class="nav-number">6.1.3.3.</span> <span class="nav-text">客户端构建(监视构建 clientManifest)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#热更新"><span class="nav-number">6.1.3.4.</span> <span class="nav-text">热更新</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写通用代码"><span class="nav-number">7.</span> <span class="nav-text">编写通用代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器上的数据相应"><span class="nav-number">7.1.</span> <span class="nav-text">服务器上的数据相应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件生命周期钩子函数"><span class="nav-number">7.2.</span> <span class="nav-text">组件生命周期钩子函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问特定平台-Platform-Specific-API"><span class="nav-number">7.3.</span> <span class="nav-text">访问特定平台(Platform-Specific) API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区分运行环境"><span class="nav-number">7.4.</span> <span class="nav-text">区分运行环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义指令"><span class="nav-number">7.5.</span> <span class="nav-text">自定义指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由和代码分割"><span class="nav-number">8.</span> <span class="nav-text">路由和代码分割</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置VueRouter-router-index-js"><span class="nav-number">8.1.</span> <span class="nav-text">配置VueRouter - router/index.js</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将路由注册到根实例"><span class="nav-number">8.2.</span> <span class="nav-text">将路由注册到根实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适配服务端入口"><span class="nav-number">8.3.</span> <span class="nav-text">适配服务端入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务端适配"><span class="nav-number">8.4.</span> <span class="nav-text">服务端适配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适配客户端入口"><span class="nav-number">8.5.</span> <span class="nav-text">适配客户端入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置路由出口"><span class="nav-number">8.6.</span> <span class="nav-text">配置路由出口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">8.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管理页面-Head"><span class="nav-number">9.</span> <span class="nav-text">管理页面 Head</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据预取和状态管理"><span class="nav-number">10.</span> <span class="nav-text">数据预取和状态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路分析"><span class="nav-number">10.1.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据预取"><span class="nav-number">10.2.</span> <span class="nav-text">数据预取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将预取数据同步到客户端"><span class="nav-number">10.3.</span> <span class="nav-text">将预取数据同步到客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">11.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eline</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
