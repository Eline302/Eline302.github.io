<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Virtual DOM,Snabbdom,">










<meta name="description" content="本文主要讲解什么是 Virtual DOM 以及 Virtual DOM 的作用，通过一个 Virtual DOM 库 Snabbdom 真正了解什么是 Virtual DOM ，以及 Diff 算法的实现和 key 的作用。  Virtual DOM 和 DOMDOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM">
<meta name="keywords" content="Virtual DOM,Snabbdom">
<meta property="og:type" content="article">
<meta property="og:title" content="Virtual DOM理解与Snabbdom源码分析">
<meta property="og:url" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/index.html">
<meta property="og:site_name" content="Eline blog">
<meta property="og:description" content="本文主要讲解什么是 Virtual DOM 以及 Virtual DOM 的作用，通过一个 Virtual DOM 库 Snabbdom 真正了解什么是 Virtual DOM ，以及 Diff 算法的实现和 key 的作用。  Virtual DOM 和 DOMDOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/DOM-res.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode1.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/createElm.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/patchVNode.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode1.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode2.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode3.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode4.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode5.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode6.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode7.png">
<meta property="og:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode8.png">
<meta property="og:updated_time" content="2021-03-22T02:09:03.249Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Virtual DOM理解与Snabbdom源码分析">
<meta name="twitter:description" content="本文主要讲解什么是 Virtual DOM 以及 Virtual DOM 的作用，通过一个 Virtual DOM 库 Snabbdom 真正了解什么是 Virtual DOM ，以及 Diff 算法的实现和 key 的作用。  Virtual DOM 和 DOMDOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM">
<meta name="twitter:image" content="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/DOM-res.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/">





  <title>Virtual DOM理解与Snabbdom源码分析 | Eline blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eline blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eline">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eline blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Virtual DOM理解与Snabbdom源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-21T09:38:18+08:00">
                2021-01-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2021-03-22T10:09:03+08:00">
                2021-03-22
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vueJS/" itemprop="url" rel="index">
                    <span itemprop="name">vueJS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文主要讲解什么是 Virtual DOM 以及 Virtual DOM 的作用，通过一个 Virtual DOM 库 Snabbdom 真正了解什么是 Virtual DOM ，以及 Diff 算法的实现和 key 的作用。</p>
</blockquote>
<h2 id="Virtual-DOM-和-DOM"><a href="#Virtual-DOM-和-DOM" class="headerlink" title="Virtual DOM 和 DOM"></a>Virtual DOM 和 DOM</h2><p>DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分（例如:页面元素、字符串或注释等等）。</p>
<h3 id="什么是-Virtual-DOM"><a href="#什么是-Virtual-DOM" class="headerlink" title="什么是 Virtual DOM"></a>什么是 Virtual DOM</h3><p>Virtual DOM(虚拟 DOM)，是由普通的的 JS 对象来描述 DOM 对象，因为不是真实的 DOM 对象，所以叫 Virtual DOM 。</p>
<ul>
<li>真实 DOM 成员</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>Hello Virtual DOM<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> s = <span class="string">''</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> element) &#123; </span></span><br><span class="line"><span class="javascript">          s += key + <span class="string">','</span> </span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(s) </span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打印结果：<br><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/DOM-res.png" alt="DOM"><br>通过打印结果得知，一个DOM对象的成员有很多，从而创建一个DOM成本是非常高的。</p>
<ul>
<li>可以使用 Virtual DOM 来描述真实 DOM</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 选择器</span></span><br><span class="line">    sel: <span class="string">"div"</span>,  </span><br><span class="line">    <span class="comment">// 模块，节点数据（属性，样式，事件等）</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 子节点，和text互斥</span></span><br><span class="line">    children: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="comment">// 节点中的文本内容</span></span><br><span class="line">    text: <span class="string">"Hello Virtual DOM"</span>, </span><br><span class="line">    <span class="comment">// 记录vnode对应的真实DOM</span></span><br><span class="line">    elm: <span class="literal">undefined</span>,</span><br><span class="line">   <span class="comment">// 节点标识（唯一） </span></span><br><span class="line">    key: <span class="literal">undefined</span> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>对比真实DOM创建VNode成本比真实DOM小很多。</p>
<h3 id="为什么使用-Virtual-DOM"><a href="#为什么使用-Virtual-DOM" class="headerlink" title="为什么使用 Virtual DOM"></a>为什么使用 Virtual DOM</h3><ul>
<li>手动操作 DOM 比较麻烦，还需要考虑浏览器兼容性问题，虽然有 jQuery 等库简化 DOM 操作，但是随着项目的复杂 DOM 操作复杂提升</li>
<li>为了简化 DOM 的复杂操作于是出现了各种 MVVM 框架，MVVM 框架解决了视图和状态的同步问题</li>
<li>为了简化视图的操作我们可以使用模板引擎，但是模板引擎没有解决跟踪状态变化的问题（数据发生变化时无法获取上次状态），于是 Virtual DOM 出现了</li>
<li>Virtual DOM 的好处是当状态改变时不需要立即更新 DOM，只需要创建一个虚拟树来描述 DOM， Virtual DOM 内部将弄清楚如何有效(diff)的更新 DOM</li>
<li>参考github上 <a href="https://github.com/Matt-Esch/virtual-dom" target="_blank" rel="noopener">virtual-dom</a> 的描述<ul>
<li>虚拟 DOM 可以维护程序的状态，跟踪上一次的状态</li>
<li>通过比较前后两次状态的差异更新真实 DOM</li>
</ul>
</li>
</ul>
<h3 id="虚拟-DOM-的作用"><a href="#虚拟-DOM-的作用" class="headerlink" title="虚拟 DOM 的作用"></a>虚拟 DOM 的作用</h3><ul>
<li>使用VNode可以记录上次状态的变化，只更新发生变化的部分</li>
<li>维护视图和状态的关系</li>
<li>复杂视图情况下提升渲染性能，简单视图首次渲染并不能提高性能</li>
<li>除了渲染 DOM 以外，还可以实现 SSR(Nuxt.js/Next.js)、原生应用(Weex/React Native)、小程序(mpvue/uni-app)等<br> <img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode.png" alt="DOM"></li>
</ul>
<h2 id="Snabbdom"><a href="#Snabbdom" class="headerlink" title="Snabbdom"></a>Snabbdom</h2><p> Vue 2.x 内部使用的Virtual DOM就是改造的<a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">Snabbdom</a>，Snabbdom内部使用TypeScript开发，是最快的Virtual DOM 之一</p>
<h3 id="Snabbdom基本使用"><a href="#Snabbdom基本使用" class="headerlink" title="Snabbdom基本使用"></a>Snabbdom基本使用</h3><p> 需求：实现一个如下html结构的web ui，其中div的text部分hello是会在[hello、visual、world]三者当中随机选择一个显示的（演示dom更新）：</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> hello</span><br><span class="line">     <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">class</span>=<span class="string">"li-1"</span>&gt;</span>first li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"2"</span> <span class="attr">class</span>=<span class="string">"li-2"</span>&gt;</span>second li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./index.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="dom实现（原生）"><a href="#dom实现（原生）" class="headerlink" title="dom实现（原生）"></a>dom实现（原生）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDivNode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> divNode = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode([<span class="string">"hello"</span>, <span class="string">"visual"</span>, <span class="string">"dom"</span>][<span class="built_in">Date</span>.now()%<span class="number">3</span>]);</span><br><span class="line">    divNode.appendChild(textNode);</span><br><span class="line">    <span class="keyword">const</span> notesNode = <span class="built_in">document</span>.createComment(<span class="string">"this is a notes node"</span>);</span><br><span class="line">    divNode.appendChild(notesNode);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createLiNode</span>(<span class="params">props, text</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">        <span class="keyword">for</span> (key <span class="keyword">in</span> props) &#123;</span><br><span class="line">            <span class="keyword">const</span> attr = <span class="built_in">document</span>.createAttribute(key);</span><br><span class="line">            attr.value = props[key];</span><br><span class="line">            li.setAttributeNode(attr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(text);</span><br><span class="line">        li.appendChild(textNode);</span><br><span class="line">        <span class="keyword">return</span> li;</span><br><span class="line">    &#125;</span><br><span class="line">    divNode.appendChild(createLiNode(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">class</span>: <span class="string">"li-1"</span> &#125;, <span class="string">"first li"</span>));</span><br><span class="line">    divNode.appendChild(</span><br><span class="line">        createLiNode(&#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">class</span>: <span class="string">"li-2"</span> &#125;, <span class="string">"second li"</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> divNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceDom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newDiv = createDivNode();</span><br><span class="line">    app.parentNode.appendChild(newDiv);</span><br><span class="line">    app.parentNode.removeChild(app);</span><br><span class="line">    app = newDiv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"init"</span>:</span><br><span class="line">    replaceDom();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"update"</span>:</span><br><span class="line">    replaceDom();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">render(<span class="string">"init"</span>);</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">render(<span class="string">"update"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h4 id="virtual-dom实现（snabbdom）"><a href="#virtual-dom实现（snabbdom）" class="headerlink" title="virtual dom实现（snabbdom）"></a>virtual dom实现（snabbdom）</h4><ul>
<li><p>项目中引入snabbdom可以通过script标签和npm形式引入，此案例使用npm方式</p>
<ul>
<li><p>script方式引入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/snabbdom/0.7.4/snabbdom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/snabbdom/0.7.4/h.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>npm方式引入：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add parcel-bundler  # 本地安装 parcel 打包工具</span><br><span class="line">$ yarn add snabbdom  # snabbdom</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>配置 package.json 的 scripts</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123; </span><br><span class="line">        <span class="string">"dev"</span>: <span class="string">"parcel index.html --open"</span>, </span><br><span class="line">        <span class="string">"build"</span>: <span class="string">"parcel build index.html"</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>index.js</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exports是在nodejs12中中开始支持，webpack4和parcel是不支持的，webpack5中开始支持exports，所以此处不能直接使用官方文档提供的写法，需要导入完整的路径</span></span><br><span class="line">    <span class="keyword">import</span> &#123; init &#125; <span class="keyword">from</span> <span class="string">'snabbdom/build/package/init'</span></span><br><span class="line">    <span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">'snabbdom/build/package/h'</span></span><br><span class="line">    <span class="keyword">let</span> app = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>);</span><br><span class="line">    <span class="comment">/** -- init() 使用 init() 函数创建 patch() </span></span><br><span class="line"><span class="comment">     * 参 数： 数组，将来可以传入模块，处理属性/样式/事件等 </span></span><br><span class="line"><span class="comment">     * 返回值：patch函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> patch = init([])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createDivVNode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">createLiVNode</span>(<span class="params">sel, text</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> h(sel, text);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** -- h() 函数创建 vnode </span></span><br><span class="line"><span class="comment">         * 第一个参数：标签 + 选择器</span></span><br><span class="line"><span class="comment">         * 第二个参数：若是字符串，则表示标签中的内容</span></span><br><span class="line"><span class="comment">         *            若是数组， 则表示创建标签中的子元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> vnode = h(<span class="string">"div"</span>, [</span><br><span class="line">            [<span class="string">"hello"</span>, <span class="string">"visual"</span>, <span class="string">"dom"</span>][<span class="built_in">Date</span>.now()%<span class="number">3</span>],</span><br><span class="line">            <span class="comment">// h('!') 是创建注释 </span></span><br><span class="line">            h(<span class="string">"!"</span>, <span class="string">"this is a notes node"</span>),</span><br><span class="line">            createLiVNode(<span class="string">"li"</span>, <span class="string">"first li"</span>),</span><br><span class="line">            createLiVNode(<span class="string">"li"</span>, <span class="string">"second li"</span>),</span><br><span class="line">        ]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vnode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"init"</span>:</span><br><span class="line">            <span class="comment">/** -- patch() 对比两个vnode的差异，更新到真实DOM</span></span><br><span class="line"><span class="comment">             * 第一个参数：旧VNode  可以是 DOM元素，则内部会把DOM元素转换成VNode；也可以是 VNode</span></span><br><span class="line"><span class="comment">             * 第二个参数：新VNode</span></span><br><span class="line"><span class="comment">             * 返回值：新的 VNode </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            app = patch(app, createDivVNode());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"update"</span>:</span><br><span class="line">            app = patch(app, createDivVNode());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render(<span class="string">"init"</span>);</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    render(<span class="string">"update"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述示例中可以看到：DOM 方式实现是使用 DOM 提供的 API 编写渲染 DOM 结构即可。那么对于 virtual dom 库 snbbdom 是如何实现的 dom 渲染？通过代码可以看到，使用 snabbdom 的 init() 函数创建 patch()，通过h函数创建虚拟节点vnode，patch 函数用于把 vnode 渲染到 app 的位置，更新时再把新的虚拟节点渲染在老的虚拟节点位置上，后面我们将通过snabbdom源码来研究下内部实现原理的。</p>
<blockquote>
<p>需要注意，查看官方文档是可以看到案例是通过<code>import { init } from &#39;snabbdom/init&#39;</code>方式引入，此时运行的话会告诉我们找不到 init / h 模块，查看源码得知模块路径并不是 snabbdom/int，这个路径是在 <a href="https://github.com/snabbdom/snabbdom/blob/master/package.json" target="_blank" rel="noopener">package.json</a> 中的 exports 字段设置的，而我们使用的parcel打包工具不支持 exports 这个字段，webpack 4 也不支持，webpack 5 支持该字段,该字段在导入 snabbdom/init 的时候会补全路径成 snabbdom/build/package/init.js,如果使用不支持 package.json 的 exports 字段的打包工具，我们应该把模块的路径写全既<code>import { init } from &#39;snabbdom/build/package/init&#39;</code></p>
</blockquote>
<h4 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h4><p>Snabbdom 的核心库并不能处理DOM元素的属性/样式/事件等，如果需要处理的话，可以使用snabbdom默认提供的模块来实现，snabbdom中模块的实现是通过注册全局的钩子函数来实现。</p>
<p>官方提供了 6 个模块</p>
<ul>
<li>attributes<ul>
<li>设置 DOM 元素的属性，使用 setAttribute()</li>
<li>处理布尔类型的属性</li>
</ul>
</li>
<li>props<ul>
<li>和 attributes 模块相似，设置 DOM 元素的属性 element[attr] = value</li>
<li>不处理布尔类型的属性</li>
</ul>
</li>
<li>class<ul>
<li>切换类样式</li>
<li>注意：给元素设置类样式是通过 sel 选择器</li>
</ul>
</li>
<li>dataset<ul>
<li>设置 data-* 的自定义属性</li>
</ul>
</li>
<li>eventlisteners<ul>
<li>注册和移除事件</li>
</ul>
</li>
<li>style<ul>
<li>设置行内样式，支持动画</li>
<li>delayed/remove/destroy</li>
</ul>
</li>
</ul>
<p><strong>模块使用</strong></p>
<ul>
<li>模块使用步骤：<ul>
<li>导入需要的模块</li>
<li>init() 中注册模块</li>
<li>使用 h() 函数创建 VNode 的时候，可以把第二个参数设置为对象，其他参数往后移</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; init&#125; <span class="keyword">from</span> <span class="string">'snabbdom/build/package/init'</span></span><br><span class="line"><span class="keyword">import</span> &#123;h&#125; <span class="keyword">from</span> <span class="string">'snabbdom/build/package/h'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; styleModule &#125; <span class="keyword">from</span> <span class="string">'snabbdom/build/package/modules/style'</span> </span><br><span class="line"><span class="keyword">import</span> &#123; eventListenersModule &#125; <span class="keyword">from</span> <span class="string">'snabbdom/build/package/modules/eventlisteners'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 init() 函数创建 patch()</span></span><br><span class="line"><span class="comment">// init() 的参数是数组，将来可以传入模块，处理属性/样式/事件等</span></span><br><span class="line"><span class="keyword">let</span> patch = init([</span><br><span class="line">  <span class="comment">// 注册模块</span></span><br><span class="line">  styleModule,</span><br><span class="line">  eventListenersModule</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 h() 函数创建 vnode</span></span><br><span class="line"><span class="keyword">let</span> vnode = h(<span class="string">'div.cls'</span>, &#123;</span><br><span class="line">  <span class="comment">// 设置 DOM 元素的行内样式</span></span><br><span class="line">  style: &#123; <span class="attr">color</span>: <span class="string">'#DEDEDE'</span>, <span class="attr">backgroundColor</span>: <span class="string">'#181A1B'</span> &#125;,</span><br><span class="line">  <span class="comment">// 注册事件</span></span><br><span class="line">  on: &#123; <span class="attr">click</span>: clickHandler &#125;</span><br><span class="line">&#125;, [</span><br><span class="line">  h(<span class="string">'h1'</span>, <span class="string">'Hello Snabbdom'</span>),</span><br><span class="line">  h(<span class="string">'p'</span>, <span class="string">'这是段落'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此处的 this 指向对应的 vnode</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.elm.innerHTML)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="snabbdom源码分析"><a href="#snabbdom源码分析" class="headerlink" title="snabbdom源码分析"></a><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom源码分析</a></h3><p><strong>Snabbdom 的核心</strong></p>
<ul>
<li>使用 h() 函数创建 JavaScript 对象(VNode)描述真实 DOM</li>
<li>init() 设置模块，创建 patch()</li>
<li>patch() 比较新旧两个 VNode</li>
<li>把变化的内容更新到真实 DOM 树上</li>
</ul>
<p>snabbdom目录结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">|—— .vscode --------------------------- 开发工具的配置文件</span><br><span class="line">|—— examples -------------------------- 官方提示示例</span><br><span class="line">  ├── hero ---------------------------- 演示自定义模块</span><br><span class="line">  ├── reorder-animation --------------- 演示过度动画的列表</span><br><span class="line">|—— perf ------------------------------ 性能测试</span><br><span class="line">|—— src  ------------------------------ 源码</span><br><span class="line">  ├── package</span><br><span class="line">  │   ├── helpers</span><br><span class="line">  │   │   └── attachto.ts ------------- 定义了 vnode.ts 中 AttachData 的数据结构</span><br><span class="line">  │   ├── modules --------------------- 所有模块的定义</span><br><span class="line">  │   │   ├── attributes.ts</span><br><span class="line">  │   │   ├── class.ts</span><br><span class="line">  │   │   ├── dataset.ts</span><br><span class="line">  │   │   ├── eventlisteners.ts</span><br><span class="line">  │   │   ├── hero.ts ----------------- example 中使用到的自定义钩子</span><br><span class="line">  │   │   ├── module.ts --------------- 定义了模块中用到的钩子函数</span><br><span class="line">  │   │   ├── props.ts</span><br><span class="line">  │   │   └── style.ts</span><br><span class="line">  │   ├── h.ts ----------------------- h() 函数，用来创建 VNode</span><br><span class="line">  │   ├── hooks.ts ------------------- 声明周期用到的所有钩子函数的定义，类似于vue生命周期钩子函数</span><br><span class="line">  │   ├── htmldomapi.ts -------------- 对 DOM API 的包装（元素的增删改查）</span><br><span class="line">  │   ├── init.ts -------------------- 加载 modules、DOMAPI，返回 patch 函数</span><br><span class="line">  │   ├── is.ts ---------------------- 判断数组和原始值的函数</span><br><span class="line">  │   ├── jsx-global.ts -------------- jsx 的类型声明文件</span><br><span class="line">  │   ├── jsx.ts --------------------- 处理 jsx</span><br><span class="line">  │   ├── thunk.ts ------------------- 优化处理，对复杂视图不可变值得优化</span><br><span class="line">  │   ├── tovnode.ts ----------------- 提供一个函数把DOM 转换成 VNode（patch函数内部使用这个函数转换）</span><br><span class="line">  │   ├── ts-transform-js-extension.cjs</span><br><span class="line">  │   ├── tsconfig.json -------------- ts 的编译配置文件</span><br><span class="line">  │   └── vnode.ts ------------------- 虚拟节点定义</span><br><span class="line">  |── test --------------------------- 单元测试</span><br></pre></td></tr></table></figure></p>
<h4 id="snabbdom如何通过h函数创建Virtual-Node？"><a href="#snabbdom如何通过h函数创建Virtual-Node？" class="headerlink" title="snabbdom如何通过h函数创建Virtual Node？"></a>snabbdom如何通过h函数创建Virtual Node？</h4><h5 id="h-函数"><a href="#h-函数" class="headerlink" title="h() 函数"></a>h() 函数</h5><ul>
<li><p>在使用 Vue 的时候见过 h() 函数，Vue中增强了 h 函数，实现了组件的机制</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>h() 函数最早见于 <a href="https://github.com/hyperhype/hyperscript" target="_blank" rel="noopener">hyperscript</a>，使用 JavaScript 创建超文本，也就是 html 字符串</p>
</li>
<li>Snabbdom 中的 h() 函数不是用来创建超文本，而是创建 <strong>VNode</strong></li>
</ul>
<p><strong>重载</strong></p>
<ul>
<li>参数个数或类型不同的函数</li>
<li>JavaScript 中没有重载的概念</li>
<li>TypeScript 中有重载，不过重载的实现还是通过代码调整参数</li>
</ul>
<p>在源码中，snabbdom通过函数重载方式提供给用户四种调用h函数的方式，而后定义了一个h函数处理参数，并且调用vnode函数创建一个VNode对象返回</p>
<p>源码位置：<code>src/package/h.ts</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h函数重载 (前四个)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">h</span> (<span class="params">sel: string</span>): <span class="title">VNode</span>   // <span class="title">h1</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">h</span> (<span class="params">sel: string, data: VNodeData | null</span>): <span class="title">VNode</span>  // <span class="title">h2</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">h</span> (<span class="params">sel: string, children: VNodeChildren</span>): <span class="title">VNode</span> // <span class="title">h3</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">h</span> (<span class="params">sel: string, data: VNodeData | null, children: VNodeChildren</span>): <span class="title">VNode</span>  // <span class="title">h4</span></span></span><br><span class="line"><span class="function">// <span class="title">h</span>函数的真正实现，<span class="title">ts</span>支持重载，<span class="title">js</span>不支持重载</span></span><br><span class="line"><span class="function">// <span class="title">ts</span>代码编译为<span class="title">js</span>代码后只有一个<span class="title">h</span>函数，参数的差异是通过在函数内部通过判断类型来实现的</span></span><br><span class="line"><span class="function">// 此函数作用：用来判断参数的个数了类型</span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="title">function</span> <span class="title">h</span> (<span class="params">sel: any, b?: any, c?: any</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data: VNodeData = &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> children: any</span><br><span class="line">  <span class="keyword">var</span> text: any</span><br><span class="line">  <span class="keyword">var</span> i: number</span><br><span class="line">  <span class="comment">// 输入解析（重载）1.调用者传入三个参数，b视为data(属性节点)，c视为children/text(子节点)，对应传参方式h4</span></span><br><span class="line">  <span class="comment">// 处理参数，实现重载的机制</span></span><br><span class="line">  <span class="keyword">if</span> (c !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理三个参数的情况</span></span><br><span class="line">    <span class="comment">// sel、data、children/text</span></span><br><span class="line">    <span class="keyword">if</span> (b !== <span class="literal">null</span>) &#123;</span><br><span class="line">      data = b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果c是数组</span></span><br><span class="line">    <span class="keyword">if</span> (is.array(c)) &#123;</span><br><span class="line">      children = c</span><br><span class="line">    <span class="comment">// 如果c是字符串或者数字</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(c)) &#123;</span><br><span class="line">      text = c</span><br><span class="line">      <span class="comment">// 如果c是VNode</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &amp;&amp; c.sel) &#123;</span><br><span class="line">      children = [c]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> </span><br><span class="line">  <span class="comment">// 输入解析（重载）2.调用者传入两个参数。判断b类型后把b视为children/text或者data，对应传参方式h2或h3</span></span><br><span class="line">  <span class="keyword">if</span> (b !== <span class="literal">undefined</span> &amp;&amp; b !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is.array(b)) &#123;</span><br><span class="line">      children = b</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(b)) &#123;</span><br><span class="line">      text = b</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &amp;&amp; b.sel) &#123;</span><br><span class="line">      children = [b]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; data = b &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 输入解析（重载）3：调用者只传了一个参数时，视为只传入一个带选择器的空标签，对应于传参方式h1</span></span><br><span class="line">  <span class="comment">// 预处理逻辑1，把文本转换为VNode</span></span><br><span class="line">  <span class="keyword">if</span> (children !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理children中的原始值（string/number）</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">      <span class="comment">// 正常情况下children都是vnode对象</span></span><br><span class="line">      <span class="comment">// 如果child是string/number，说明用户没有调用h函数，此处调用vnode函数将string/number转换为VNode对象，此处的VNode是用来描述文本节点</span></span><br><span class="line">      <span class="keyword">if</span> (is.primitive(children[i])) children[i] = vnode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, children[i], <span class="literal">undefined</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 预处理逻辑2，为SVG添加命名空间</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    sel[<span class="number">0</span>] === <span class="string">'s'</span> &amp;&amp; sel[<span class="number">1</span>] === <span class="string">'v'</span> &amp;&amp; sel[<span class="number">2</span>] === <span class="string">'g'</span> &amp;&amp;</span><br><span class="line">    (sel.length === <span class="number">3</span> || sel[<span class="number">3</span>] === <span class="string">'.'</span> || sel[<span class="number">3</span>] === <span class="string">'#'</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果是svg,添加命名空间</span></span><br><span class="line">    addNS(data, children, sel)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用vnode函数创建一个VNode对象并返回</span></span><br><span class="line">  <span class="keyword">return</span> vnode(sel, data, children, text, <span class="literal">undefined</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于h函数的具体函数逻辑则在第五个h函数当中，它主要做了三件事情：</p>
<ul>
<li>首先，解析参数输入实现函数重载</li>
<li>其次，进行输入预处理，先是子节点的输入分为两种类型（为的是加快效率），即单文本children节点和children节点数组，而后为svg添加命名空间。</li>
<li>最后，转给vnode函数取出data中的key后构造一个vNode节点对象</li>
</ul>
<h5 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h5><p>h函数是通过调用 VNode 函数创建了一个 VNode 对象，下面具体看下 VNode 对象包含什么</p>
<p>源码位置：<code>src/package/vnode.ts</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key 用来表示唯一标识当前的vnode对象</span></span><br><span class="line"><span class="keyword">export</span> type Key = string | number</span><br><span class="line"><span class="comment">//用来约束最终创建的VNode对象需要具有哪些属性</span></span><br><span class="line"><span class="keyword">export</span> interface VNode &#123;</span><br><span class="line">  <span class="comment">// 选择器</span></span><br><span class="line">  sel: string | <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 描述模块中所需要的的数据</span></span><br><span class="line">  <span class="comment">// 模块，节点数据：属性/样式/事件等</span></span><br><span class="line">  data: VNodeData | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 子节点，和 text 只能互斥</span></span><br><span class="line">  children: <span class="built_in">Array</span>&lt;VNode | string&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 记录 vnode 对应的真实 DOM</span></span><br><span class="line">  elm: Node | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 对应节点中的文本内容，和 children 只能互斥</span></span><br><span class="line">  text: string | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 优化用</span></span><br><span class="line">  key: Key | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 约束data的类型，VNode中data属性</span></span><br><span class="line"><span class="keyword">export</span> interface VNodeData &#123;</span><br><span class="line">  props?: Props</span><br><span class="line">  attrs?: Attrs</span><br><span class="line">  class?: Classes</span><br><span class="line">  style?: VNodeStyle</span><br><span class="line">  dataset?: Dataset</span><br><span class="line">  on?: On</span><br><span class="line">  hero?: Hero</span><br><span class="line">  attachData?: AttachData</span><br><span class="line">  hook?: Hooks</span><br><span class="line">  key?: Key</span><br><span class="line">  ns?: string <span class="comment">// for SVGs</span></span><br><span class="line">  fn?: <span class="function"><span class="params">()</span> =&gt;</span> VNode <span class="comment">// for thunks</span></span><br><span class="line">  args?: any[] <span class="comment">// for thunks</span></span><br><span class="line">  [key: string]: any <span class="comment">// for any other 3rd party module</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vnode的实现</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">vnode</span> (<span class="params">sel: string | undefined,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: any | undefined,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: Array&lt;VNode | string&gt; | undefined,</span></span></span><br><span class="line"><span class="function"><span class="params">  text: string | undefined,</span></span></span><br><span class="line"><span class="function"><span class="params">  elm: Element | Text | undefined</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// key是通过data来赋值</span></span><br><span class="line">  <span class="keyword">const</span> key = data === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : data.key</span><br><span class="line">  <span class="comment">// 返回了普通的js对象，具有vnode接口定义的6个属性，</span></span><br><span class="line">  <span class="comment">// vnode的作用就是用来描述真实DOM，创建vnode时候可以根据需要传入对应的参数</span></span><br><span class="line">  <span class="keyword">return</span> &#123; sel, data, children, text, elm, key &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="snabbdom如何通过patch函数渲染Virtual-Node？"><a href="#snabbdom如何通过patch函数渲染Virtual-Node？" class="headerlink" title="snabbdom如何通过patch函数渲染Virtual Node？"></a>snabbdom如何通过patch函数渲染Virtual Node？</h4><h5 id="patch-整体执行过程"><a href="#patch-整体执行过程" class="headerlink" title="patch 整体执行过程"></a>patch 整体执行过程</h5><ul>
<li>patch(oldVnode, newVnode) —— snabbdom的核心</li>
<li>打补丁，把新节点中变化的内容渲染到真实 DOM，最后返回新节点作为下一次处理的旧节点</li>
<li>对比新旧 VNode 是否相同节点(节点的 key(节点唯一标识) 和 sel(节点选择器) 相同)</li>
<li>如果不是相同节点，删除之前的内容，重新渲染</li>
<li>如果是相同节点，再判断新的 VNode 是否有 text，如果有并且和 oldVnode 的 text 不同，直接更新文本内容</li>
<li>如果新的 VNode 有 children，判断子节点是否有变化，判断子节点的过程使用的就是 <strong>diff 算法</strong></li>
<li>diff 过程只进行同层级比较</li>
</ul>
<p><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode1.png" alt="diff"></p>
<p>VNode中为什么要使用Diff算法?<br>渲染真实DOM的开销很大，DOM操作会引起浏览器的重拍和重绘，即浏览器重新渲染，性能消耗比较大<br>diff 算法核心：当数据变化后，不直接操作DOM，用js对象描述真实DOM，当数据变化后会先比较js对象是否发生变化，找到所有变化的位置，最小化的更新变化的位置，从而提高性能</p>
<p>接下来我们看下patch函数是如果创建的？</p>
<p>从之前的示例中我们可以得知，patch函数是通过调用init函数得到的，我们先来探讨一下init函数。</p>
<h5 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h5><p>init函数负责接收用户传入的模块数组参数和渲染平台domApi参数，通过闭包的方式返回一个构造好外部环境的用于渲染Virtual Node的patch函数。</p>
<p>init(modules, domApi)，返回 patch() 函数（高阶函数）</p>
<blockquote>
<p>为什么要使用高阶函数？<br>1.因为 patch() 函数在外部会调用多次，每次调用依赖一些参数，比如：modules/domApi/cbs<br>2.通过高阶函数让 init() 内部形成闭包，返回的 patch() 可以访问到 modules/domApi/cbs，而不需要重新创建</p>
</blockquote>
<p>源码位置：<code>src/package/init.ts</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储了钩子函数的名字</span></span><br><span class="line"><span class="keyword">const</span> hooks: (keyof Module)[] = [<span class="string">'create'</span>, <span class="string">'update'</span>, <span class="string">'remove'</span>, <span class="string">'destroy'</span>, <span class="string">'pre'</span>, <span class="string">'post'</span>];</span><br><span class="line"><span class="comment">// domAPI 执行DOM操作</span></span><br><span class="line"><span class="comment">// 把vnode对象转换为其他平台对应的元素，不传默认设置为操作浏览器平台DOM的API</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">modules: Array&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: number, <span class="attr">j</span>: number, cbs = (&#123;&#125; <span class="keyword">as</span> ModuleHooks);</span><br><span class="line">  <span class="comment">// 初始化转换虚拟节点的 api</span></span><br><span class="line">  <span class="keyword">const</span> api: DOMAPI = domApi !== <span class="literal">undefined</span> ? domApi : htmlDomApi;</span><br><span class="line">  <span class="comment">// 把传入的所有模块的钩子函数，统一存储到 cbs 对象中</span></span><br><span class="line">  <span class="comment">// 最终构建的 cbs 对象的形式 cbs = &#123; create: [], update: [], ... &#125;</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</span><br><span class="line">      <span class="comment">// cbs.create = [], cbs.update = [], ...</span></span><br><span class="line">      cbs[hooks[i]] = [];</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</span><br><span class="line">          <span class="comment">// modules 传入的模块数组</span></span><br><span class="line">          <span class="comment">// 获取模块中的 hook 函数</span></span><br><span class="line">          <span class="comment">// hook = modules[0][create]...</span></span><br><span class="line">          <span class="keyword">const</span> hook = modules[j][hooks[i]];</span><br><span class="line">          <span class="keyword">if</span> (hook !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">              <span class="comment">// 把获取到的hook函数放入到 cbs 对应的钩子函数数组中</span></span><br><span class="line">              (cbs[hooks[i]] <span class="keyword">as</span> <span class="built_in">Array</span>&lt;any&gt;).push(hook);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">emptyNodeAt</span> (<span class="params">elm: Element</span>) </span>&#123;</span><br><span class="line">      ······</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRmCb</span> (<span class="params">childElm: Node, listeners: number</span>) </span>&#123;</span><br><span class="line">      ······</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建 vnode 对应的 DOM 元素</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params">vnode: VNode, insertedVnodeQueue: VNodeQueue</span>): <span class="title">Node</span> </span>&#123;</span><br><span class="line">      ······</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addVnodes</span> (<span class="params">parentElm: Node,before: Node | null,vnodes: VNode[],startIdx: number,endIdx: number,insertedVnodeQueue: VNodeQueue</span>)</span>&#123;</span><br><span class="line">      ······</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行 destroy 钩子函数（会执行所有子节点的 destroy 钩子函数）</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">invokeDestroyHook</span> (<span class="params">vnode: VNode</span>) </span>&#123;</span><br><span class="line">      ······</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeVnodes</span> (<span class="params">parentElm: Node, vnodes: VNode[], startIdx: number, endIdx: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">      ······</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对比新旧节点的 children，更新 DOM</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm: Node, oldCh: VNode[],newCh: VNode[],insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">      ······</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对比 oldVnode 和 vnode 的差异，把差异渲染到 DOM</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">      ······</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// init 内部返回 patch 函数，把vnode渲染成真实 dom，并返回vnode</span></span><br><span class="line">  <span class="comment">// 高阶函数，在一个函数内部返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">      .....</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init函数的输入参数有：模块数组modules和平台的domApi作为参数。</p>
<ul>
<li>模块数组参数modules通过钩子机制使得snabbdom具备了可扩展性（snabbdom核心部分只具备解析id、class以及key属性的功能，其它属性以及事件机制都在钩子模块中实现）</li>
<li>domApi参数使得snabbdom具备了跨平台渲染的能力，默认值为htmlDomApi</li>
</ul>
<p>除了modules和domApi之外，init函数的函数体中还为patch函数定义了一些工具变量和函数以便patch函数调用，下面我们看下patch函数内部的实现</p>
<h5 id="patch函数"><a href="#patch函数" class="headerlink" title="patch函数"></a>patch函数</h5><p>patch函数的职责是接收一个老的虚拟node对象和一个新的虚拟node对象，然后用新的虚拟node对象的信息去更新老的虚拟node对象，更新完成后返回新的虚拟node对象以作为下一次更新的老的虚拟node对象。</p>
<p>执行过程：</p>
<ul>
<li>首先执行模块中的钩子函数 pre</li>
<li>如果 oldVnode 和 vnode 相同（key 和 sel 相同）<ul>
<li>调用 patchVnode()，找节点的差异并更新 DOM</li>
</ul>
</li>
<li>如果 oldVnode 是 DOM 元素<ul>
<li>把 DOM 元素转换成 oldVnode</li>
<li>调用 createElm() 把 vnode 转换为真实 DOM，记录到 vnode.elm</li>
<li>把刚创建的 DOM 元素插入到 parent 中</li>
<li>移除老节点</li>
<li>触发用户设置的 create 钩子函数</li>
</ul>
</li>
</ul>
<p>源码位置：<code>src/package/init.ts</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init 内部返回 patch 函数，把vnode渲染成真实 dom，并返回vnode（高阶函数，在一个函数内部返回一个函数）</span></span><br><span class="line"><span class="comment">// oldVnode参数的类型为 VNode或Element，这样设计的目的是为了兼容第一次更新，这时，老的节点对象是dom元素（如示例中的id为app的div元素）而不是虚拟node节点。</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i: number, <span class="attr">elm</span>: Node, <span class="attr">parent</span>: Node</span><br><span class="line">  <span class="comment">// 保存新插入节点的队列，为了触发钩子函数</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue: VNodeQueue = []</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.pre.length; ++i) cbs.pre[i]()</span><br><span class="line">  <span class="comment">// 1.如果 oldVnode 不是 VNode，创建 VNode 并设置 elm,如果是就转换为虚拟dom节点</span></span><br><span class="line">  <span class="keyword">if</span> (!isVnode(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// 把 DOM 元素转换成空的 VNode</span></span><br><span class="line">    oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.如果新旧节点是相同节点(key 和 sel 相同)</span></span><br><span class="line">  <span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">    <span class="comment">// 如果相同，找新旧节点的差异并使用新节点更新老节点的DOM</span></span><br><span class="line">    patchVnode(oldVnode, vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果新旧节点不同，vnode 创建对应的 DOM（使用新节点替换老节点）</span></span><br><span class="line">    <span class="comment">// 获取当前的 DOM 元素</span></span><br><span class="line">    elm = oldVnode.elm!</span><br><span class="line">    parent = api.parentNode(elm) <span class="keyword">as</span> Node</span><br><span class="line">    <span class="comment">// 创建 vnode 对应的 DOM 元素，并触发 init/create 钩子函数</span></span><br><span class="line">    <span class="comment">// 把VNode节点转换为对应的DOM元素，把DOM元素存储到VNode对象的Element属性中并没有把创建的DOM元素挂载在DOM树上</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果父节点不为空，把 vnode 对应的 DOM　插入到文档中</span></span><br><span class="line">      <span class="comment">// ! typescript 语法，告诉编译器vnode.elm是百分百有值的</span></span><br><span class="line">      <span class="comment">// 调用insertBefore时候把VNode中存储的elm属性对应的DOM元素插入到parent（DOM树）中</span></span><br><span class="line">      api.insertBefore(parent, vnode.elm!, api.nextSibling(elm))</span><br><span class="line">      <span class="comment">// 移除老节点</span></span><br><span class="line">      removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行用户设置的 insert 钩子函数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insertedVnodeQueue.length; ++i) &#123;</span><br><span class="line">    insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行模块的 post 钩子函数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.post.length; ++i) cbs.post[i]()</span><br><span class="line">  <span class="comment">// 返回 vnode</span></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="snabbdom如何通过createElm函数把Virtual-Node转为Dom-Node？"><a href="#snabbdom如何通过createElm函数把Virtual-Node转为Dom-Node？" class="headerlink" title="snabbdom如何通过createElm函数把Virtual Node转为Dom Node？"></a>snabbdom如何通过createElm函数把Virtual Node转为Dom Node？</h4><h5 id="createElm函数"><a href="#createElm函数" class="headerlink" title="createElm函数"></a>createElm函数</h5><p>createElm函数以虚拟node对象作为输入，经过一定的逻辑转换后返回输出一个dom节点。需要注意的是，在前面说到，需要创建的dom节点的类型可以分为四种，即文本节点、注释节点、属性节点和元素节点。<br>用户想要创建哪一种节点类型在调用h函数创建虚拟node节点时已经告诉了snabbdom，但是虚拟node对象却不区分这些类型，所以在转换过程中，我们要把用户希望创建的节点类型给解析回来，然后创建对应的dom类型节点。</p>
<p><strong>执行过程：</strong><br> <img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/createElm.png" alt="createElm"></p>
<ul>
<li>首先触发用户设置的 init 钩子函数</li>
<li>把 vnode 转换成 DOM 对象，存储到 vnode.elm 中</li>
<li>如果选择器是!，创建注释节点</li>
<li>如果选择器为空，创建文本节点</li>
<li>如果选择器不为空<ul>
<li>创建对应的 DOM 对象：解析选择器，设置标签的 id 和 class 属性</li>
<li>执行模块的 create 钩子函数</li>
<li>如果 vnode 有 children，创建子 vnode 对应的 DOM，追加到 DOM 树</li>
<li>如果 vnode 的 text 值是 string/number，创建文本节点并追击到 DOM 树</li>
<li>执行用户设置的 create 钩子函数</li>
<li>如果有用户设置的 insert 钩子函数，把 vnode 添加到队列中</li>
</ul>
</li>
<li>返回 vnode.elm</li>
</ul>
<p>源码位置：<code>src/package/init.ts</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用：把 VNode 转换成对应的 DOM 元素，但是并不会把 DOM 渲染到页面中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span>(<span class="params">vnode: VNode, insertedVnodeQueue: VNodeQueue</span>): <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i: any, </span><br><span class="line">    <span class="comment">//使用h函数时候传入的第二个参数，data中可以传入真实DOM需要的属性以及vnode的钩子函数</span></span><br><span class="line">    data = vnode.data;</span><br><span class="line">    <span class="keyword">if</span> (data !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行用户设置的 init 的钩子函数</span></span><br><span class="line">        <span class="keyword">const</span> init = data.hook?.init; <span class="comment">// ?. 用来判断hook是否有值，有值返回hook.init,没有就返回undefined</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(init)) &#123; </span><br><span class="line">            init(vnode); </span><br><span class="line">            data = vnode.data; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把 vnode 转换成真实 DOM 对象（没有渲染到页面）</span></span><br><span class="line">    <span class="keyword">let</span> children = vnode.children, sel = vnode.sel;</span><br><span class="line">    <span class="keyword">if</span> (sel === <span class="string">'!'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果选择器是!，创建注释节点</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">            vnode.text = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vnode.elm = api.createComment(vnode.text!);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sel !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果选择器不为空</span></span><br><span class="line">        <span class="comment">// 解析选择器</span></span><br><span class="line">        <span class="comment">// Parse selector </span></span><br><span class="line">        <span class="keyword">const</span> hashIdx = sel.indexOf(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">const</span> dotIdx = sel.indexOf(<span class="string">'.'</span>, hashIdx);</span><br><span class="line">        <span class="keyword">const</span> hash = hashIdx &gt; <span class="number">0</span> ? hashIdx : sel.length;</span><br><span class="line">        <span class="keyword">const</span> dot = dotIdx &gt; <span class="number">0</span> ? dotIdx : sel.length;</span><br><span class="line">        <span class="keyword">const</span> tag = hashIdx !== <span class="number">-1</span> || dotIdx !== <span class="number">-1</span> ? sel.slice(<span class="number">0</span>, <span class="built_in">Math</span>.min(hash, dot)) : sel;</span><br><span class="line">        <span class="comment">// data.ns 是否有命名空间</span></span><br><span class="line">        <span class="keyword">const</span> elm = vnode.elm = isDef(data) &amp;&amp; isDef(i = (data <span class="keyword">as</span> VNodeData).ns) ? api.createElementNS(i, tag)</span><br><span class="line">        : api.createElement(tag);</span><br><span class="line">        <span class="keyword">if</span> (hash &lt; dot) elm.setAttribute(<span class="string">'id'</span>, sel.slice(hash + <span class="number">1</span>, dot));</span><br><span class="line">        <span class="keyword">if</span> (dotIdx &gt; <span class="number">0</span>) elm.setAttribute(<span class="string">'class'</span>, sel.slice(dot + <span class="number">1</span>).replace(<span class="regexp">/\./g</span>, <span class="string">' '</span>));</span><br><span class="line">        <span class="comment">// 执行模块的 create 钩子函数</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);</span><br><span class="line">        <span class="comment">// 如果 vnode 中有子节点，创建子 vnode 对应的 DOM 元素，并追加到 DOM 树上</span></span><br><span class="line">        <span class="keyword">if</span> (is.array(children)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> ch = children[i];</span><br><span class="line">                <span class="keyword">if</span> (ch != <span class="literal">null</span>) &#123;</span><br><span class="line">                    api.appendChild(elm, createElm(ch <span class="keyword">as</span> VNode, insertedVnodeQueue));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is.primitive(vnode.text)) &#123;</span><br><span class="line">            <span class="comment">// 如果 vnode 的 text 值是 string/number，创建文本节点，并追加到 DOM 树上</span></span><br><span class="line">            api.appendChild(elm, api.createTextNode(vnode.text));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> hook = vnode.data!.hook; </span><br><span class="line">        <span class="keyword">if</span> (isDef(hook)) &#123; </span><br><span class="line">            <span class="comment">// 执行用户传入的钩子 create </span></span><br><span class="line">            hook.create?.(emptyNode, vnode); </span><br><span class="line">            <span class="keyword">if</span> (hook.insert) &#123; </span><br><span class="line">                <span class="comment">// 把 vnode 添加到队列中，为后续执行 insert 钩子做准备</span></span><br><span class="line">                insertedVnodeQueue.push(vnode); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果选择器为空，创建文本节点</span></span><br><span class="line">        vnode.elm = api.createTextNode(vnode.text!);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新创建的 DOM</span></span><br><span class="line">    <span class="keyword">return</span> vnode.elm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="snabbdom如何通过patchVnode函数和updateChildren函数实现Virtual-Node更新（Dom-diff算法）？"><a href="#snabbdom如何通过patchVnode函数和updateChildren函数实现Virtual-Node更新（Dom-diff算法）？" class="headerlink" title="snabbdom如何通过patchVnode函数和updateChildren函数实现Virtual Node更新（Dom diff算法）？"></a>snabbdom如何通过patchVnode函数和updateChildren函数实现Virtual Node更新（Dom diff算法）？</h4><p>实现Virtual Node更新也就是以生成新虚拟node对应的dom结构为目标，通过最大限度的从现有的dom树中寻找并复用已有的dom节点的方式减少dom节点的创建和渲染，加快UI渲染速度。<br>从算法角度来说，就是实现树节点的差异更新，也就是diff算法。</p>
<h5 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h5><p>patchNode函数负责在新旧节点相同后，把新虚拟节点渲染在旧虚拟节点对应的dom节点位置上</p>
<p><strong>执行过程：</strong><br> <img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/patchVNode.png" alt="patchVNode"></p>
<ul>
<li>首先执行用户设置的 prepatch 钩子函数</li>
<li>执行 create 钩子函数<ul>
<li>首先执行模块的 create 钩子函数</li>
<li>然后执行用户设置的 create 钩子函数</li>
</ul>
</li>
<li>如果 vnode.text 未定义<ul>
<li>如果 oldVnode.children 和 vnode.children 都有值<ul>
<li>调用 updateChildren()</li>
<li>使用 diff 算法对比子节点，更新子节点</li>
</ul>
</li>
<li>如果 vnode.children 有值，oldVnode.children 无值<ul>
<li>清空 DOM 元素</li>
<li>调用 addVnodes()，批量添加子节点</li>
</ul>
</li>
<li>如果 oldVnode.children 有值，vnode.children 无值<ul>
<li>调用 removeVnodes()，批量移除子节点</li>
</ul>
</li>
<li>如果 oldVnode.text 有值<ul>
<li>清空 DOM 元素的内容</li>
</ul>
</li>
</ul>
</li>
<li>如果设置了 vnode.text 并且和和 oldVnode.text 不等<ul>
<li>如果老节点有子节点，全部移除</li>
<li>设置 DOM 元素的 textContent 为 vnode.text</li>
</ul>
</li>
<li>最后执行用户设置的 postpatch 钩子函数</li>
</ul>
<p>源码位置：src/package/init.ts</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> hook = vnode.data?.hook;</span><br><span class="line">    <span class="comment">// 首先执行用户设置的 prepatch 钩子函数</span></span><br><span class="line">    hook?.prepatch?.(oldVnode, vnode);</span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm!;</span><br><span class="line">    <span class="keyword">let</span> oldCh = oldVnode.children <span class="keyword">as</span> VNode[];</span><br><span class="line">    <span class="keyword">let</span> ch = vnode.children <span class="keyword">as</span> VNode[];</span><br><span class="line">    <span class="comment">// 如果新老 vnode 相同，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (vnode.data !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行模块的 update 钩子函数</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);</span><br><span class="line">        <span class="comment">// 执行用户设置的 update 钩子函数</span></span><br><span class="line">       vnode.data.hook?.update?.(oldVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 vnode.text 未定义</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">        <span class="comment">// 如果新老节点都有 children</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">            <span class="comment">// 使用 diff 算法对比子节点，更新子节点</span></span><br><span class="line">            <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">            <span class="comment">// 如果新节点有 children，老节点没有 children</span></span><br><span class="line">            <span class="comment">// 如果老节点有 text，清空 dom 元素的内容</span></span><br><span class="line">            <span class="keyword">if</span> (isDef(oldVnode.text)) api.setTextContent(elm, <span class="string">''</span>);</span><br><span class="line">            <span class="comment">// 批量添加子节点</span></span><br><span class="line">            addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">            <span class="comment">// 如果老节点有 children，新节点没有 children</span></span><br><span class="line">            <span class="comment">// 批量移除子节点</span></span><br><span class="line">            removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">            <span class="comment">// 如果老节点有 text，清空 DOM　元素</span></span><br><span class="line">            api.setTextContent(elm, <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">        <span class="comment">// 如果没有设置 vnode.text</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">            <span class="comment">// 如果老节点有 children，移除</span></span><br><span class="line">            removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 DOM 元素的 textContent 为 vnode.text</span></span><br><span class="line">        api.setTextContent(elm, vnode.text!);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后执行用户设置的 postpatch 钩子函数</span></span><br><span class="line">    hook?.postpatch?.(oldVnode, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h5><p>updateChildren函数负责在新旧节点相同后，把新虚拟节点的子节点与老虚拟节点的子结点数组进行比较后差异更新（diff 算法的核心，对比新旧节点的 children，更新 DOM）</p>
<p><strong>执行过程</strong>：</p>
<ul>
<li>要对比两棵树的差异，我们可以取第一棵树的每一个节点依次和第二课树的每一个节点比较，但是这样的时间复杂度为 O(n^3)(传统的diff)<br>传统的diff算法是：将两棵树中所有节点一一对比需要O(n^2)，在加上更新（移动，创建，删除）时需要遍历一次，所以是O(n^3)</li>
<li><p>因此只需要找<strong>同级别的子节点依次比较</strong>，然后再找下一级别的节点比较，这样算法的时间复杂度为 O(n)<br>snbbdom根据DOM的特点对传统的diff算法做了优化，DOM操作时候会很少跨级别操作节点，值对比同级别的节点，n个节点需要对比n次，时间复杂度为O(n)</p>
<p><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode1.png" alt="diff"></p>
</li>
<li><p>在进行同级别节点比较的时候，首先会对新老节点数组的开始和结尾节点设置标记索引，遍历的过程中移动索引</p>
</li>
<li><p>在对开始和结束节点比较的时候，总共有四种情况</p>
<ul>
<li>oldStartVnode / newStartVnode (旧开始节点 / 新开始节点)</li>
<li>oldEndVnode / newEndVnode (旧结束节点 / 新结束节点)</li>
<li>oldStartVnode / oldEndVnode (旧开始节点 / 新结束节点)</li>
<li>oldEndVnode / newStartVnode (旧结束节点 / 新开始节点)</li>
</ul>
<p><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode2.png" alt="diff"></p>
</li>
<li><p>开始节点和结束节点比较，这两种情况类似</p>
<ul>
<li>oldStartVnode / newStartVnode (旧开始节点 / 新开始节点)</li>
<li>oldEndVnode / newEndVnode (旧结束节点 / 新结束节点)</li>
</ul>
</li>
<li><p>如果 oldStartVnode 和 newStartVnode 是 sameVnode (key 和 sel 相同)</p>
<ul>
<li>调用 patchVnode() 对比和更新节点</li>
<li>把旧开始和新开始索引往后移动  oldStartIdx++ / oldEndIdx++</li>
</ul>
<p><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode3.png" alt="diff"></p>
</li>
<li><p>oldStartVnode / newEndVnode (旧开始节点 / 新结束节点) 相同</p>
<ul>
<li>调用 patchVnode() 对比和更新节点</li>
<li>把 oldStartVnode 对应的 DOM 元素，移动到右边<ul>
<li>更新索引</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode4.png" alt="diff"></p>
</li>
<li><p>oldEndVnode / newStartVnode (旧结束节点 / 新开始节点) 相同</p>
<ul>
<li>调用 patchVnode() 对比和更新节点</li>
<li>把 oldEndVnode 对应的 DOM 元素，移动到左边<ul>
<li>更新索引</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode5.png" alt="diff"></p>
</li>
<li><p>如果不是以上四种情况</p>
<ul>
<li>遍历新节点，使用 newStartNode 的 key 在老节点数组中找相同节点</li>
<li>如果没有找到，说明 newStartNode 是新节点<ul>
<li>创建新节点对应的 DOM 元素，插入到 DOM 树中</li>
</ul>
</li>
<li>如果找到了<ul>
<li>判断新节点和找到的老节点的 sel 选择器是否相同</li>
<li>如果不相同，说明节点被修改了<ul>
<li>重新创建对应的 DOM 元素，插入到 DOM 树中</li>
</ul>
</li>
<li>如果相同，把 elmToMove 对应的 DOM 元素，移动到左边</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode6.png" alt="diff"></p>
</li>
<li><p>循环结束</p>
<ul>
<li>当老节点的所有子节点先遍历完 (oldStartIdx &gt; oldEndIdx)，循环结束</li>
<li>新节点的所有子节点先遍历完 (newStartIdx &gt; newEndIdx)，循环结束</li>
</ul>
</li>
<li><p>如果老节点的数组先遍历完(oldStartIdx &gt; oldEndIdx)，说明新节点有剩余，把剩余节点批量插入到右边</p>
<p><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode7.png" alt="diff"></p>
</li>
<li><p>如果新节点的数组先遍历完(newStartIdx &gt; newEndIdx)，说明老节点有剩余，把剩余节点批量删除</p>
<p><img src="/2021/01/21/Virtual-DOM理解与Snabbdom源码分析/vnode8.png" alt="diff"></p>
</li>
</ul>
<p>这里有一个视频通过动画的形式讲解了Diff算法：<a href="https://www.bilibili.com/video/BV1b5411V7i3" target="_blank" rel="noopener">图解 Vue.js Virtual DOM 的 Diff 算法核心</a></p>
<p>源码位置：<code>src/package/init.ts</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VNode 的核心</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm: Node,</span></span></span><br><span class="line"><span class="function"><span class="params">                         oldCh: Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                         newCh: Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                         insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 新老开始节点的索引</span></span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 老的结束节点的索引</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 老的开始节点</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 老的结束节点</span></span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">    <span class="comment">// 新的结束节点的索引</span></span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 新的开始节点</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 新的结束节点</span></span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">    <span class="comment">// 存储对象，对象中键是老节点对应的key值是老节点的索引，方便根据新节点key找到对应老节点在数组中的索引 </span></span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx: any;</span><br><span class="line">    <span class="comment">// 存储老节点的索引</span></span><br><span class="line">    <span class="keyword">let</span> idxInOld: number;</span><br><span class="line">    <span class="keyword">let</span> elmToMove: VNode;</span><br><span class="line">    <span class="comment">// 当新节点在老节点中找到相同key的老节点，存储对应的老节点Before:存储插入的参考元素</span></span><br><span class="line">    <span class="keyword">let</span> before: any;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比所有的新旧子节点</span></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="comment">// 索引变化后,可能会把节点设置为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 节点为空移动索引</span></span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode might have been moved left</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">            <span class="comment">// 比较开始和结束节点的四种情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            <span class="comment">// 1. 比较老的开始节点和新的开始节点</span></span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            <span class="comment">// 2. 比较老的结束节点和新的结束节点</span></span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">            <span class="comment">// 3. 比较老的开始节点和新的结束节点</span></span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">            api.insertBefore(parentElm, oldStartVnode.elm!, api.nextSibling(oldEndVnode.elm!));</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">            <span class="comment">// 4. 比较老的结束节点和新的开始节点</span></span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">            api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 开始节点和结束节点都不相同</span></span><br><span class="line">            <span class="comment">// 使用 newStartNode 的 key 在老的节点数组中找相同节点</span></span><br><span class="line">            <span class="comment">// 先设置记录 key 和 index 的对象</span></span><br><span class="line">            <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历 newStartVnode,从老的节点中找相同 key 的 oldVnode 的索引</span></span><br><span class="line">            idxInOld = oldKeyToIdx[newStartVnode.key <span class="keyword">as</span> string];</span><br><span class="line">            <span class="comment">// 如果是新的 vnode</span></span><br><span class="line">            <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">                <span class="comment">// 如果没找到,newStartVnode 是新节点</span></span><br><span class="line">                <span class="comment">// 创建元素插入 DOM 树</span></span><br><span class="line">                api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm!);</span><br><span class="line">                <span class="comment">// 重新给 newStartVnode 赋值,指向下一个新节点</span></span><br><span class="line">                newStartVnode = newCh[++newStartIdx];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果找到相同 key 相同的老节点,记录到 elmToMove 遍历</span></span><br><span class="line">                elmToMove = oldCh[idxInOld];</span><br><span class="line">                <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">                    <span class="comment">// 如果新旧节点的选择器不同</span></span><br><span class="line">                    <span class="comment">// 创建新开始节点对应的 DOM 元素,插入到 DOM 树中</span></span><br><span class="line">                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm!);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果相同,patchVnode()</span></span><br><span class="line">                    <span class="comment">// 把 elmToMove 对应的 DOM 元素,移动到左边</span></span><br><span class="line">                    patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">undefined</span> <span class="keyword">as</span> any;</span><br><span class="line">                    api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 重新给 newStartVnode 赋值,指向下一个新节点</span></span><br><span class="line">                newStartVnode = newCh[++newStartIdx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环结束,老节点数组先遍历完成或者新节点数组先遍历完成</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">            <span class="comment">// 如果老节点数组先遍历完成,说明有新的节点剩余</span></span><br><span class="line">            <span class="comment">// 把剩余的新节点都插入到右边</span></span><br><span class="line">            before = newCh[newEndIdx+<span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx+<span class="number">1</span>].elm;</span><br><span class="line">            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果新节点数组先遍历完成,说明老节点有剩余</span></span><br><span class="line">            <span class="comment">// 批量删除老节点</span></span><br><span class="line">            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码发现，在通常情况下，snabbdom的做法和我们上面说的一样，用新节点数组中的节点一一去匹配老节点数组中的节点，有则移动或更新（注意老节点只复用一次），无则创建并插入。</p>
<p>节点设置key与不设置key有什么不同？</p>
<ul>
<li>当选择器的sel都相同时，未设置key，新旧节点会被认为是相同的节点，只会更改老节点的text或者children属性从而最大限度的重用现有DOM</li>
<li>当选择器的sel都相同时，设置key时，他会对比在diff中用来比较是否是相同的节点，如果不同会移动老节点的DOM元素来匹配新数据项的顺序，从而重用和重排现有元素，减少DOM操作</li>
</ul>
<h4 id="Hooks-函数-和-模块-Modules"><a href="#Hooks-函数-和-模块-Modules" class="headerlink" title="Hooks 函数 和 模块 Modules"></a>Hooks 函数 和 模块 Modules</h4><ul>
<li>snabbdom核心： patch() -&gt; patchVnode() -&gt; updateChildren()</li>
<li>Snabbdom 为了保证核心库的精简，把处理元素的属性/事件/样式等工作，放置到模块中</li>
<li>模块可以按照需要引入</li>
<li>模块的使用可以<a href="https://github.com/snabbdom/snabbdom#modules-documentation" target="_blank" rel="noopener">查看官方文档</a></li>
<li>模块实现的核心是基于 Hooks</li>
</ul>
<h5 id="Hooks-函数"><a href="#Hooks-函数" class="headerlink" title="Hooks 函数"></a>Hooks 函数</h5><p>预定义的钩子函数的名称<br>源码位置：<code>src/package/hooks.ts</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> interface Hooks &#123;</span><br><span class="line">    <span class="comment">// patch 函数开始执行的时候触发</span></span><br><span class="line">    pre?: PreHook;</span><br><span class="line">    <span class="comment">// createElm 函数开始之前的时候触发</span></span><br><span class="line">    <span class="comment">// 在把 VNode 转换成真实 DOM 之前触发</span></span><br><span class="line">    init?: InitHook;</span><br><span class="line">    <span class="comment">// createElm 函数末尾调用</span></span><br><span class="line">    <span class="comment">// 创建完真实 DOM 后触发</span></span><br><span class="line">    create?: CreateHook;</span><br><span class="line">    <span class="comment">// patchVnode 函数末尾执行</span></span><br><span class="line">    <span class="comment">// 真实 DOM 添加到 DOM　树中触发</span></span><br><span class="line">    insert?: InsertHook;</span><br><span class="line">    <span class="comment">// patchVnode 函数开头调用</span></span><br><span class="line">    <span class="comment">// 开始对比两个 VNode 的差异之前触发</span></span><br><span class="line">    prepatch?: PrePatchHook;</span><br><span class="line">    <span class="comment">// patchVnode 函数开头调用</span></span><br><span class="line">    <span class="comment">// 两个 VNode 对比过程中触发,比 prepatch 稍晚</span></span><br><span class="line">    update?: UpdateHook;</span><br><span class="line">    <span class="comment">// patchVnode 的最末尾调用</span></span><br><span class="line">    <span class="comment">// 两个 VNode 对比结束执行</span></span><br><span class="line">    postpatch?: PostPatchHook;</span><br><span class="line">    <span class="comment">// removeVnodes -&gt; inVokeDestroyHook 中调用</span></span><br><span class="line">    <span class="comment">// 在删除元素之前触发,子节点的 destroy 也被触发</span></span><br><span class="line">    destroy?: DestroyHook;</span><br><span class="line">    <span class="comment">// removeVnodes 中调用</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    remove?: RemoveHook;</span><br><span class="line">    post?: PostHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块 Modules"></a>模块 Modules</h5><p>Snabbdom 提供的所有模块在：<code>src/package/modules</code> 文件夹下，主要模块有：</p>
<p>modules目录结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|—— attributes.ts --------------------------- 使用 setAttribute/removeAttribute 操作属性,能够处理 boolean 类型的属性</span><br><span class="line">|—— class.ts -------------------------------- 切换类样式</span><br><span class="line">|—— dataset.ts ------------------------------ 操作元素的 data-* 属性</span><br><span class="line">|—— eventlisteners.ts  ---------------------- 注册和移除事件</span><br><span class="line">|—— module.ts  ------------------------------ 定义模块遵守的钩子函数</span><br><span class="line">|—— props.ts  ------------------------------- 和 attributes.ts 类似，但是是使用 elm[attrName] = value 的方式操作属性</span><br><span class="line">|—— style.ts  ------------------------------- 操作行内样式,可以使动画更平滑</span><br><span class="line">|—— hero.ts  -------------------------------- 自定义的模块，examples/hero 示例中使用</span><br></pre></td></tr></table></figure></p>
<p>attributes.ts</p>
<ul>
<li>模块到出成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> attributesModule = &#123; </span><br><span class="line">    create: updateAttrs, </span><br><span class="line">    update: updateAttrs </span><br><span class="line">&#125; <span class="keyword">as</span> Module; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> attributesModule;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>updateAttrs 函数功能<br>1.更新节点属性<br>2.如果节点属性值是 true 设置空置<br>3.如果节点属性值是 false 移除属性</p>
</li>
<li><p>updateAttrs 实现</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateAttrs</span>(<span class="params">oldVnode: VNode, vnode: VNode</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key: string, <span class="attr">elm</span>: Element = vnode.elm <span class="keyword">as</span> Element,</span><br><span class="line">        oldAttrs = (oldVnode.data <span class="keyword">as</span> VNodeData).attrs,</span><br><span class="line">        attrs = (vnode.data <span class="keyword">as</span> VNodeData).attrs;</span><br><span class="line">    <span class="comment">// 新老节点没有 attrs 属性,返回</span></span><br><span class="line">    <span class="keyword">if</span> (!oldAttrs &amp;&amp; !attrs) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 新老节点的 attrs 属性相同,返回</span></span><br><span class="line">    <span class="keyword">if</span> (oldAttrs === attrs) <span class="keyword">return</span>;</span><br><span class="line">    oldAttrs = oldAttrs || &#123;&#125;;</span><br><span class="line">    attrs = attrs || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update modified attributes, add new attributes</span></span><br><span class="line">    <span class="comment">// 遍历新节点的属性</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> attrs) &#123;</span><br><span class="line">        <span class="comment">// 新老节点的属性值</span></span><br><span class="line">        <span class="keyword">const</span> cur = attrs[key];</span><br><span class="line">        <span class="keyword">const</span> old = oldAttrs[key];</span><br><span class="line">        <span class="comment">// 如果新老节点的属性值不同</span></span><br><span class="line">        <span class="keyword">if</span> (old !== cur) &#123;</span><br><span class="line">            <span class="comment">// 布尔类型值的处理</span></span><br><span class="line">            <span class="keyword">if</span> (cur === <span class="literal">true</span>) &#123;</span><br><span class="line">                elm.setAttribute(key, <span class="string">""</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur === <span class="literal">false</span>) &#123;</span><br><span class="line">                elm.removeAttribute(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// xChar -&gt; x</span></span><br><span class="line">                <span class="comment">// &lt;svg xmlns="http://www.w3.org/2000/scg"&gt;</span></span><br><span class="line">                <span class="keyword">if</span> (key.charCodeAt(<span class="number">0</span>) !== xChar) &#123;</span><br><span class="line">                    elm.setAttribute(key, cur);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.charCodeAt(<span class="number">3</span>) === colonChar) &#123;</span><br><span class="line">                    <span class="comment">// colonChar -&gt; :</span></span><br><span class="line">                    <span class="comment">// Assume xml namespace</span></span><br><span class="line">                    elm.setAttributeNS(xmlNS, key, cur);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.charCodeAt(<span class="number">5</span>) === colonChar) &#123;</span><br><span class="line">                    <span class="comment">// Assume xlink namespace</span></span><br><span class="line">                    <span class="comment">// &lt;svg xmlns:xlink="http://www.w3.org/1999/xlink"&gt;</span></span><br><span class="line">                    elm.setAttributeNS(xlinkNS, key, cur);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    elm.setAttribute(key, cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// remove removed attributes</span></span><br><span class="line">    <span class="comment">// use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)</span></span><br><span class="line">    <span class="comment">// the other option is to remove all attributes with value == undefined</span></span><br><span class="line">    <span class="comment">// 如果老节点的属性在新节点中不存在,移除</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> oldAttrs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> attrs)) &#123;</span><br><span class="line">            elm.removeAttribute(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener">MDN DOM概述</a><br><a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">算法的时间复杂度</a><br><a href="https://blog.csdn.net/jw2268136570/article/details/112715755" target="_blank" rel="noopener">snabbdom源码分析</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Virtual-DOM/" rel="tag"># Virtual DOM</a>
          
            <a href="/tags/Snabbdom/" rel="tag"># Snabbdom</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/12/vue-router原理剖析/" rel="next" title="vue-router原理剖析">
                <i class="fa fa-chevron-left"></i> vue-router原理剖析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/28/【Vue.js源码解析 一】-- 响应式原理/" rel="prev" title="【Vue.js源码学习】--响应式原理">
                【Vue.js源码学习】--响应式原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/cat.jpg" alt="Eline">
            
              <p class="site-author-name" itemprop="name">Eline</p>
              <p class="site-description motion-element" itemprop="description">Web前端开发</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Eline302" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-DOM-和-DOM"><span class="nav-number">1.</span> <span class="nav-text">Virtual DOM 和 DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-Virtual-DOM"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 Virtual DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么使用-Virtual-DOM"><span class="nav-number">1.2.</span> <span class="nav-text">为什么使用 Virtual DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟-DOM-的作用"><span class="nav-number">1.3.</span> <span class="nav-text">虚拟 DOM 的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Snabbdom"><span class="nav-number">2.</span> <span class="nav-text">Snabbdom</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Snabbdom基本使用"><span class="nav-number">2.1.</span> <span class="nav-text">Snabbdom基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dom实现（原生）"><span class="nav-number">2.1.1.</span> <span class="nav-text">dom实现（原生）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#virtual-dom实现（snabbdom）"><span class="nav-number">2.1.2.</span> <span class="nav-text">virtual dom实现（snabbdom）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内置模块"><span class="nav-number">2.1.3.</span> <span class="nav-text">内置模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#snabbdom源码分析"><span class="nav-number">2.2.</span> <span class="nav-text">snabbdom源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#snabbdom如何通过h函数创建Virtual-Node？"><span class="nav-number">2.2.1.</span> <span class="nav-text">snabbdom如何通过h函数创建Virtual Node？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#h-函数"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">h() 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#VNode"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">VNode</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#snabbdom如何通过patch函数渲染Virtual-Node？"><span class="nav-number">2.2.2.</span> <span class="nav-text">snabbdom如何通过patch函数渲染Virtual Node？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#patch-整体执行过程"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">patch 整体执行过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#init函数"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">init函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#patch函数"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">patch函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#snabbdom如何通过createElm函数把Virtual-Node转为Dom-Node？"><span class="nav-number">2.2.3.</span> <span class="nav-text">snabbdom如何通过createElm函数把Virtual Node转为Dom Node？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#createElm函数"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">createElm函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#snabbdom如何通过patchVnode函数和updateChildren函数实现Virtual-Node更新（Dom-diff算法）？"><span class="nav-number">2.2.4.</span> <span class="nav-text">snabbdom如何通过patchVnode函数和updateChildren函数实现Virtual Node更新（Dom diff算法）？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#patchVnode"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">patchVnode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#updateChildren"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">updateChildren</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hooks-函数-和-模块-Modules"><span class="nav-number">2.2.5.</span> <span class="nav-text">Hooks 函数 和 模块 Modules</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Hooks-函数"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">Hooks 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模块-Modules"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">模块 Modules</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eline</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
